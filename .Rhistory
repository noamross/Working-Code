setwd('/Users/noamross/Dropbox/Workspace/_WorkingCode/OldStuff')
rm(list=ls()) #clear workspace
setwd('/Users/noamross/Dropbox/Workspace/_WorkingCode/OldStuff')
source("fit_ode.R") #load functions
setwd('/Users/noamross/Dropbox/Workspace/_WorkingCode/OldStuff')
#set parameters#
r = c(0.7816, 0.6283)  #r and K are given#
K = c(559.686, 202.4931)#
alphas = rbind(c(1,"a21"),c("a12",1)) #create alpha matrix with unknowns#
parms = list(r=r,K=K,alphas=alphas)  #bind into named list#
guesses = c(a21=0.5, a12=0.5)	#create named vector of guesses#
nTrue = as.matrix(read.table("paramecium2.txt")) #load data
setwd('/Users/noamross/Dropbox/Workspace/_WorkingCode/OldStuff')
nTrue = as.matrix(read.table("./data/paramecium2.txt")) #load data
setwd('/Users/noamross/Dropbox/Workspace/_WorkingCode/OldStuff')
nTrue = as.matrix(read.table("../data/paramecium2.txt")) #load data
setwd('/Users/noamross/Dropbox/Workspace/_WorkingCode/OldStuff')
#run fitting function#
fit = fit_ode(LotVolt,parms,guesses,nTrue) #
#
#calculate some values for plotting#
times = 1:dim(nTrue)[1]   #times vector#
parms2 = numeric.list(replace.variables(fit$par, parms)) #create parameter list with fitted outputs#
nSim = lsoda(nTrue[1,],times,LotVolt,parms2) #solve the ODEs with fitted values#
#
#plots#
plot(times,nTrue[,1], main="Lotka-Volterra ODE Model fit to Data",xlab="time",ylab="Population")  #plot the real data#
points(times,nTrue[,2])#
lines(times,nSim[,2])	#add the model fit lines#
lines(times,nSim[,3])#
legend("topleft",c("Data","Model Fit"),lty=c("blank","solid"),pch=c(1,NA_integer_)) #create a legend#
text(3.3,300,bquote(alpha[21] == .(fit$par[1])))  #annotate with alpha values#
text(3.3,280,bquote(alpha[12] == .(fit$par[2])))
d :s df :s :d df _df Noam Ross#
Graduate Group in Ecology#
Department of Environmental Science and Policy#
University of California at Davis#
+1.646.244.0484#
http://www.noamross.net/#
twitter: @noamross
setwd('/Users/noamross/.Trash/Workdir')
r = c(0.7816, 0.6283)  #r and K are given
setwd('/Users/noamross/.Trash/Workdir')
r = c(0.7816, 0.6283)  #r and K are given
parms = list(r=r,K=K,alphas=alphas)  #bind into named list
nTrue = as.matrix(read.table("paramecium2.txt")) #load data
guesses = c(a21=0.5, a12=0.5)	#create named vector of guesses
nTrue = as.matrix(read.table("paramecium2.txt")) #load data
nTrue = as.matrix(read.table("../data/paramecium2.txt")) #load data
nTrue = as.matrix(read.table(data/paramecium2.txt")) #load data
nTure
nTrue
rm(list=ls()) #clear workspace#
#
source("fit_ode.R") #load functions#
#
#
#set parameters#
r = c(0.7816, 0.6283)  #r and K are given#
K = c(559.686, 202.4931)#
alphas = rbind(c(1,"a21"),c("a12",1)) #create alpha matrix with unknowns#
parms = list(r=r,K=K,alphas=alphas)  #bind into named list#
guesses = c(a21=0.5, a12=0.5)	#create named vector of guesses#
nTrue = as.matrix(read.table("paramecium2.txt")) #load data#
#
#run fitting function#
fit = fit_ode(LotVolt,parms,guesses,nTrue) #
#
#calculate some values for plotting#
times = 1:dim(nTrue)[1]   #times vector#
parms2 = numeric.list(replace.variables(fit$par, parms)) #create parameter list with fitted outputs#
nSim = lsoda(nTrue[1,],times,LotVolt,parms2) #solve the ODEs with fitted values#
#
#plots#
plot(times,nTrue[,1], main="Lotka-Volterra ODE Model fit to Data",xlab="time",ylab="Population")  #plot the real data#
points(times,nTrue[,2])#
lines(times,nSim[,2])	#add the model fit lines#
lines(times,nSim[,3])#
legend("topleft",c("Data","Model Fit"),lty=c("blank","solid"),pch=c(1,NA_integer_)) #create a legend#
text(3.3,300,bquote(alpha[21] == .(fit$par[1])))  #annotate with alpha values#
text(3.3,280,bquote(alpha[12] == .(fit$par[2])))
rm(list=ls()) #clear workspace#
#
source("fit_ode.R") #load functions#
#
#
#set parameters#
r = c(0.7816, 0.6283)  #r and K are given#
K = c(559.686, 202.4931)#
alphas = rbind(c(1,"a21"),c("a12",1)) #create alpha matrix with unknowns#
parms = list(r=r,K=K,alphas=alphas)  #bind into named list#
guesses = c(a21=0.5, a12=0.5)	#create named vector of guesses#
nTrue = as.matrix(read.table("data/paramecium2.txt")) #load data#
#
#run fitting function#
fit = fit_ode(LotVolt,parms,guesses,nTrue) #
#
#calculate some values for plotting#
times = 1:dim(nTrue)[1]   #times vector#
parms2 = numeric.list(replace.variables(fit$par, parms)) #create parameter list with fitted outputs#
nSim = lsoda(nTrue[1,],times,LotVolt,parms2) #solve the ODEs with fitted values#
#
#plots#
plot(times,nTrue[,1], main="Lotka-Volterra ODE Model fit to Data",xlab="time",ylab="Population")  #plot the real data#
points(times,nTrue[,2])#
lines(times,nSim[,2])	#add the model fit lines#
lines(times,nSim[,3])#
legend("topleft",c("Data","Model Fit"),lty=c("blank","solid"),pch=c(1,NA_integer_)) #create a legend#
text(3.3,300,bquote(alpha[21] == .(fit$par[1])))  #annotate with alpha values#
text(3.3,280,bquote(alpha[12] == .(fit$par[2])))
rm(list=ls()) #clear workspace#
#
source("OldStuff/fit_ode.R") #load functions#
#
#
#set parameters#
r = c(0.7816, 0.6283)  #r and K are given#
K = c(559.686, 202.4931)#
alphas = rbind(c(1,"a21"),c("a12",1)) #create alpha matrix with unknowns#
parms = list(r=r,K=K,alphas=alphas)  #bind into named list#
guesses = c(a21=0.5, a12=0.5)	#create named vector of guesses#
nTrue = as.matrix(read.table("data/paramecium2.txt")) #load data#
#
#run fitting function#
fit = fit_ode(LotVolt,parms,guesses,nTrue) #
#
#calculate some values for plotting#
times = 1:dim(nTrue)[1]   #times vector#
parms2 = numeric.list(replace.variables(fit$par, parms)) #create parameter list with fitted outputs#
nSim = lsoda(nTrue[1,],times,LotVolt,parms2) #solve the ODEs with fitted values#
#
#plots#
plot(times,nTrue[,1], main="Lotka-Volterra ODE Model fit to Data",xlab="time",ylab="Population")  #plot the real data#
points(times,nTrue[,2])#
lines(times,nSim[,2])	#add the model fit lines#
lines(times,nSim[,3])#
legend("topleft",c("Data","Model Fit"),lty=c("blank","solid"),pch=c(1,NA_integer_)) #create a legend#
text(3.3,300,bquote(alpha[21] == .(fit$par[1])))  #annotate with alpha values#
text(3.3,280,bquote(alpha[12] == .(fit$par[2])))
[1] 559.6860 202.4931
setwd('/Users/noamross/.Trash/Workdir')
r = c(0.7816, 0.6283)  #r and K are given#
K = c(559.686, 202.4931)#
alphas = rbind(c(1,"a21"),c("a12",1)) #create alpha matrix with unknowns#
parms = list(r=r,K=K,alphas=alphas)  #bind into named list#
guesses = c(a21=0.5, a12=0.5)	#create named vector of guesses
setwd('/Users/noamross/.Trash/Workdir')
r = c(0.7816, 0.6283)  #r and K are given#
K = c(559.686, 202.4931)#
alphas = rbind(c(1,"a21"),c("a12",1)) #create alpha matrix with unknowns#
parms = list(r=r,K=K,alphas=alphas)  #bind into named list#
guesses = c(a21=0.5, a12=0.5)	#create named vector of guesses
parms = list(r=r,K=K,alphas=alphas)  #bind into named list
r = c(0.7816, 0.6283)  #r and K are given#
K = c(559.686, 202.4931)#
alphas = rbind(c(1,"a21"),c("a12",1)) #create alpha matrix with unknowns#
parms = list(r=r,K=K,alphas=alphas)  #bind into named list#
guesses = c(a21=0.5, a12=0.5)	#create named vector of guesses#
nTrue = as.matrix(read.table("data/paramecium2.txt")) #load data
source("OldStuff/fit_ode.R") #load functions
#set parameters
r = c(0.7816, 0.6283)  #r and K are given
K = c(559.686, 202.4931)
alphas = rbind(c(1,"a21"),c("a12",1)) #create alpha matrix with unknowns
rm(list=ls()) #clear workspace#
#
source("OldStuff/fit_ode.R") #load functions#
#
#
#set parameters#
r = c(0.7816, 0.6283)  #r and K are given#
K = c(559.686, 202.4931)#
alphas = rbind(c(1,"a21"),c("a12",1)) #create alpha matrix with unknowns#
parms = list(r=r,K=K,alphas=alphas)  #bind into named list#
guesses = c(a21=0.5, a12=0.5)	#create named vector of guesses#
nTrue = as.matrix(read.table("data/paramecium2.txt")) #load data#
#
#run fitting function#
fit = fit_ode(LotVolt,parms,guesses,nTrue) #
#
#calculate some values for plotting#
times = 1:dim(nTrue)[1]   #times vector#
parms2 = numeric.list(replace.variables(fit$par, parms)) #create parameter list with fitted outputs#
nSim = lsoda(nTrue[1,],times,LotVolt,parms2) #solve the ODEs with fitted values#
#
#plots#
plot(times,nTrue[,1], main="Lotka-Volterra ODE Model fit to Data",xlab="time",ylab="Population")  #plot the real data#
points(times,nTrue[,2])#
lines(times,nSim[,2])	#add the model fit lines#
lines(times,nSim[,3])#
legend("topleft",c("Data","Model Fit"),lty=c("blank","solid"),pch=c(1,NA_integer_)) #create a legend#
text(3.3,300,bquote(alpha[21] == .(fit$par[1])))  #annotate with alpha values#
text(3.3,280,bquote(alpha[12] == .(fit$par[2])))
alphas = rbind(c(1,"a21"),c("a12",1)) #create alpha matrix with unknowns
parms = list(r=r,K=K,alphas=alphas)  #bind into named list
guesses = c(a21=0.5, a12=0.5)	#create named vector of guesses
nTrue = as.matrix(read.table("data/paramecium2.txt")) #load data
#run fitting function
fit = fit_ode(LotVolt,parms,guesses,nTrue)
#calculate some values for plotting
times = 1:dim(nTrue)[1]   #times vector
parms2 = numeric.list(replace.variables(fit$par, parms)) #create parameter list with fitted outputs
nSim = lsoda(nTrue[1,],times,LotVolt,parms2) #solve the ODEs with fitted values
p = 2 #number of patches
lambda = 20 #population growth coefficient#
a = 1 #intraspecific competition term#
d = 0.04 #dispersal coefficient#
p = 2 #number of patches#
#N0 = runif(p)*10 #initial conditions#
tf = 500 #number of time steps#
N0s = seq(0,lambda/exp(1),length.out=100)
D = matrix(d/(p-1),p,p) #create disperal matrix with uniform dispersal#
diag(D) = 1-d#
#
N = matrix(0,tf,p) #create variable space for individual run outputs#
final.Ns = array(0, dim = c(rep(length(N0s), p), p))
dim(final.Ns)
#set parameters#
lambda = 20 #population growth coefficient#
a = 1 #intraspecific competition term#
d = 0.04 #dispersal coefficient#
p = 2 #number of patches#
#N0 = runif(p)*10 #initial conditions#
tf = 500 #number of time steps#
N0s = seq(0,lambda/exp(1),length.out=100) #vector of initial conditions to test#
#
#
#create dispersal matrix#
D = matrix(d/(p-1),p,p) #create disperal matrix with uniform dispersal#
diag(D) = 1-d#
#
N = matrix(0,tf,p) #create variable space for individual run outputs#
final.Ns = array(0, dim = c(rep(length(N0s), p), p))#
#
ricker.growth = function(N, lambda, a) { #density dependent growth function#
	N2 = lambda*N*exp(-a*N)#
	return(N2)#
	}
#set parameters#
lambda = 20 #population growth coefficient#
a = 1 #intraspecific competition term#
d = 0.04 #dispersal coefficient#
p = 2 #number of patches#
#N0 = runif(p)*10 #initial conditions#
tf = 500 #number of time steps#
N0s = seq(0,lambda/exp(1),length.out=10) #vector of initial conditions to test#
#
#
#create dispersal matrix#
D = matrix(d/(p-1),p,p) #create disperal matrix with uniform dispersal#
diag(D) = 1-d#
#
N = matrix(0,tf,p) #create variable space for individual run outputs#
final.Ns = array(0, dim = c(rep(length(N0s), p), p))#
#
ricker.growth = function(N, lambda, a) { #density dependent growth function#
	N2 = lambda*N*exp(-a*N)#
	return(N2)#
	}
dim(final.Ns)
for(k in 1:length(N0s)) {#
  for(j in 1:length(N0s)) {#
    N[1,] = N0s[] #set initial conditions from N0s#
#
    for(i in 1:(tf-1)) { #for each time i...#
    	N[i+1,] = D%*%ricker.growth(N[i,], lambda, a) #calculate next values of N#
    	}#
    	#
    final.Ns[k,j,] = N[length(N),]#
    }#
  }
for(k in 1:length(N0s)) {#
  for(j in 1:length(N0s)) {#
    N[1,] = c(N0s[j], N0s[k]) #set initial conditions from N0s#
#
    for(i in 1:(tf-1)) { #for each time i...#
    	N[i+1,] = D%*%ricker.growth(N[i,], lambda, a) #calculate next values of N#
    	}#
    	#
    final.Ns[k,j,] = N[length(N),]#
    }#
  }
N0s
final.Ns
N
k =1
j=1
N[1,] = c(N0s[j], N0s[k])
c(N0s[j], N0s[k])
k = 3
j = 2
c(N0s[j], N0s[k])
rm(list=ls()) #clear workspace#
#
#set parameters#
lambda = 20 #population growth coefficient#
a = 1 #intraspecific competition term#
d = 0.04 #dispersal coefficient#
p = 2 #number of patches#
#N0 = runif(p)*10 #initial conditions#
tf = 500 #number of time steps#
N0s = seq(0,lambda/exp(1),length.out=10) #vector of initial conditions to test#
#
#
#create dispersal matrix#
D = matrix(d/(p-1),p,p) #create disperal matrix with uniform dispersal#
diag(D) = 1-d#
#
N = matrix(0,tf,p) #create variable space for individual run outputs#
final.Ns = array(0, dim = c(rep(length(N0s), p), p))#
#
ricker.growth = function(N, lambda, a) { #density dependent growth function#
	N2 = lambda*N*exp(-a*N)#
	return(N2)#
	}#
#
#
for(k in 1:length(N0s)) {#
  for(j in 1:length(N0s)) {#
    N[1,] = c(N0s[j], N0s[k]) #set initial conditions from N0s#
#
    for(i in 1:(tf-1)) { #for each time i...#
    	N[i+1,] = D%*%ricker.growth(N[i,], lambda, a) #calculate next values of N#
    	}#
    	#
    final.Ns[k,j,] = N[length(N),]#
    }#
  }
N
    final.Ns[k,j,] = N[tf,]
rm(list=ls()) #clear workspace#
#
#set parameters#
lambda = 20 #population growth coefficient#
a = 1 #intraspecific competition term#
d = 0.04 #dispersal coefficient#
p = 2 #number of patches#
#N0 = runif(p)*10 #initial conditions#
tf = 500 #number of time steps#
N0s = seq(0,lambda/exp(1),length.out=10) #vector of initial conditions to test#
#
#
#create dispersal matrix#
D = matrix(d/(p-1),p,p) #create disperal matrix with uniform dispersal#
diag(D) = 1-d#
#
N = matrix(0,tf,p) #create variable space for individual run outputs#
final.Ns = array(0, dim = c(rep(length(N0s), p), p))#
#
ricker.growth = function(N, lambda, a) { #density dependent growth function#
	N2 = lambda*N*exp(-a*N)#
	return(N2)#
	}#
#
#
for(k in 1:length(N0s)) {#
  for(j in 1:length(N0s)) {#
    N[1,] = c(N0s[j], N0s[k]) #set initial conditions from N0s#
#
    for(i in 1:(tf-1)) { #for each time i...#
    	N[i+1,] = D%*%ricker.growth(N[i,], lambda, a) #calculate next values of N#
    	}#
    	#
    final.Ns[k,j,] = N[tf,]#
    }#
  }
final.Ns
image(N0s,N0s,log(abs(final.Ns[,,1] - final.Ns[,,2])))
rm(list=ls()) #clear workspace#
#
#set parameters#
lambda = 20 #population growth coefficient#
a = 1 #intraspecific competition term#
d = 0.04 #dispersal coefficient#
p = 2 #number of patches#
#N0 = runif(p)*10 #initial conditions#
tf = 500 #number of time steps#
N0s = seq(0,lambda/exp(1),length.out=100) #vector of initial conditions to test#
#
#
#create dispersal matrix#
D = matrix(d/(p-1),p,p) #create disperal matrix with uniform dispersal#
diag(D) = 1-d#
#
N = matrix(0,tf,p) #create variable space for individual run outputs#
final.Ns = array(0, dim = c(rep(length(N0s), p), p))#
#
ricker.growth = function(N, lambda, a) { #density dependent growth function#
	N2 = lambda*N*exp(-a*N)#
	return(N2)#
	}#
#
#
for(k in 1:length(N0s)) {#
  for(j in 1:length(N0s)) {#
    N[1,] = c(N0s[j], N0s[k]) #set initial conditions from N0s#
#
    for(i in 1:(tf-1)) { #for each time i...#
    	N[i+1,] = D%*%ricker.growth(N[i,], lambda, a) #calculate next values of N#
    	}#
    	#
    final.Ns[k,j,] = N[tf,]#
    }#
  }#
#
image(N0s,N0s,log(abs(final.Ns[,,1] - final.Ns[,,2])))
stop
stop#
stop()
rm(list=ls()) #clear workspace#
#
#set parameters#
lambda = 20 #population growth coefficient#
a = 1 #intraspecific competition term#
d = 0.04 #dispersal coefficient#
p = 2 #number of patches#
#N0 = runif(p)*10 #initial conditions#
tf = 500 #number of time steps#
N0s = seq(0,lambda/exp(1),length.out=100) #vector of initial conditions to test#
#
#
#create dispersal matrix#
D = matrix(d/(p-1),p,p) #create disperal matrix with uniform dispersal#
diag(D) = 1-d#
#
N = matrix(0,tf,p) #create variable space for individual run outputs#
final.Ns = array(0, dim = c(rep(length(N0s), p), p))#
#
ricker.growth = function(N, lambda, a) { #density dependent growth function#
	N2 = lambda*N*exp(-a*N)#
	return(N2)#
	}#
#
#
for(k in 1:length(N0s)) {#
  for(j in 1:length(N0s)) {#
    N[1,] = c(N0s[j], N0s[k]) #set initial conditions from N0s#
#
    for(i in 1:(tf-1)) { #for each time i...#
    	N[i+1,] = D%*%ricker.growth(N[i,], lambda, a) #calculate next values of N#
    	}#
    	#
    final.Ns[k,j,] = N[tf,]#
    }#
  }#
#
image(N0s,N0s,log(abs(final.Ns[,,1] - final.Ns[,,2])))
help(system)
system("git add .")
system("git add .", intern=TRUE)
system(git add ., intern=TRUE)
system("git add .", intern=TRUE)
image(N0s,N0s,log(abs(final.Ns[,,1] - final.Ns[,,2])), col=rainbow(128),#
      xlab="Initial Population at Patch 1",#
      ylab="Inital Population at Patch 2",#
      main="Log Population Differences of Two Patches following Hastings 1990")
##
#
rm(list=ls()) #clear workspace#
#
#set parameters#
lambda = 20 #population growth coefficient#
a = 1 #intraspecific competition term#
d = 0.04 #dispersal coefficient#
p = 2 #number of patches#
#N0 = runif(p)*10 #initial conditions#
tf = 500 #number of time steps#
N0s = seq(0,lambda/exp(1),length.out=20) #vector of initial conditions to test#
#
#
#create dispersal matrix#
D = matrix(d/(p-1),p,p) #create disperal matrix with uniform dispersal#
diag(D) = 1-d#
#
N = matrix(0,tf,p) #create variable space for individual run outputs#
final.Ns = array(0, dim = c(rep(length(N0s), p), p))#
#
ricker.growth = function(N, lambda, a) { #density dependent growth function#
	N2 = lambda*N*exp(-a*N)#
	return(N2)#
	}#
#
#
for(k in 1:length(N0s)) {#
  for(j in 1:length(N0s)) {#
    N[1,] = c(N0s[j], N0s[k]) #set initial conditions from N0s#
#
    for(i in 1:(tf-1)) { #for each time i...#
    	N[i+1,] = D%*%ricker.growth(N[i,], lambda, a) #calculate next values of N#
    	}#
    	#
    final.Ns[k,j,] = N[tf,]#
    }#
  }#
#
image(N0s,N0s,log(abs(final.Ns[,,1] - final.Ns[,,2])), col=rainbow(128),#
      xlab="Initial Population at Patch 1",#
      ylab="Inital Population at Patch 2",#
      main="Log Population Differences of Two Patches following Hastings 1990")
save(final.Ns, file="Data/HastingsModelOut")
image(N0s,N0s,log(abs(final.Ns[,,1] - final.Ns[,,2])), col=rainbow(256),#
      xlab="Initial Population at Patch 1",#
      ylab="Inital Population at Patch 2",#
      main="Log Population Differences of Two Patches following Hastings 1990")
rm(list=ls()) #clear workspace
help(save)
save("Data/HastingsModelOut")
help(save)
load("Data/HastingsModelOut")
rm(list=ls()) #clear workspace
image(N0s,N0s,log(abs(final.Ns[,,1] - final.Ns[,,2])), col=rainbow(256),#
      xlab="Initial Population at Patch 1",#
      ylab="Inital Population at Patch 2",#
      main="Log Population Differences of Two Patches following Hastings 1990")
N0s = seq(0,lambda/exp(1),length.out=20) #vector of initial conditions to test
lambda = 20 #population growth coefficient#
a = 1 #intraspecific competition term#
d = 0.04 #dispersal coefficient#
p = 2 #number of patches#
#N0 = runif(p)*10 #initial conditions#
tf = 500 #number of time steps#
N0s = seq(0,lambda/exp(1),length.out=20) #vector of initial conditions to test
image(N0s,N0s,log(abs(final.Ns[,,1] - final.Ns[,,2])), col=rainbow(256),#
      xlab="Initial Population at Patch 1",#
      ylab="Inital Population at Patch 2",#
      main="Log Population Differences of Two Patches following Hastings 1990")
load("Data/HastingsModelOut.rdata")
load("Data/HastingsModelOut")
image(N0s,N0s,log(abs(final.Ns[,,1] - final.Ns[,,2])), col=rainbow(256),#
      xlab="Initial Population at Patch 1",#
      ylab="Inital Population at Patch 2",#
      main="Log Population Differences of Two Patches following Hastings 1990")
##
#
rm(list=ls()) #clear workspace#
#
#set parameters#
lambda = 20 #population growth coefficient#
a = 1 #intraspecific competition term#
d = 0.04 #dispersal coefficient#
p = 2 #number of patches#
#N0 = runif(p)*10 #initial conditions#
tf = 500 #number of time steps#
N0s = seq(0,lambda/exp(1),length.out=400) #vector of initial conditions to test#
#
#
#create dispersal matrix#
D = matrix(d/(p-1),p,p) #create disperal matrix with uniform dispersal#
diag(D) = 1-d#
#
N = matrix(0,tf,p) #create variable space for individual run outputs#
final.Ns = array(0, dim = c(rep(length(N0s), p), p))#
#
ricker.growth = function(N, lambda, a) { #density dependent growth function#
	N2 = lambda*N*exp(-a*N)#
	return(N2)#
	}#
#
#
for(k in 1:length(N0s)) {#
  for(j in 1:length(N0s)) {#
    N[1,] = c(N0s[j], N0s[k]) #set initial conditions from N0s#
#
    for(i in 1:(tf-1)) { #for each time i...#
    	N[i+1,] = D%*%ricker.growth(N[i,], lambda, a) #calculate next values of N#
    	}#
    	#
    final.Ns[k,j,] = N[tf,]#
    }#
  }#
#
save(final.Ns, file="Data/HastingsModelOut.rdata")#
image(N0s,N0s,log(abs(final.Ns[,,1] - final.Ns[,,2])), col=rainbow(256),#
      xlab="Initial Population at Patch 1",#
      ylab="Inital Population at Patch 2",#
      main="Log Population Differences of Two Patches following Hastings 1990")
Initial=c(5, 5, 10, 10, 15, 15, 20, 20, 30, 30, 50, 50, 75, 75, 100, 100)
data=c(33,rep(0,25),rep(1,3),rep(2,2),rep(2,3),8,10,rep(0,19),12)#
Initial=c(5, 5, 10, 10, 15, 15, 20, 20, 30, 30, 50, 50, 75, 75, 100, 100)#
Killed=c(1, 2, 5, 6, 10, 9, 7, 10, 11, 15, 5, 21, 32, 18, 25, 35)
data
flips = rbinom(1,24000,0.5)
sum(flips)
ave(flips)
flips
flips = rbinom(100,24000,0.5)
ave(flips)
flips
test = dbinom(12012,24000,0.5)
test
test2 = dbinom(11988:12012,24000,0.5)
test2
sum(test)
sum(test[1:25])
sum(test2)
data=c(33,rep(0,25),rep(1,3),rep(2,2),rep(2,3),8,10,rep(0,19),12)#
hist(data)
hist(data, breaks=1)
hist(data, breaks=40)
hist(data, breaks=length(data))
length(data)
hist(data,n=34)
poisd = dpois(1:100,lambda)#
binomd = dbinom(1:00,N,lambda/N)
lambda = 1.5#
N = 100#
#
poisd = dpois(1:100,lambda)#
binomd = dbinom(1:100,N,lambda/N)
barplot(poisd)
lambda = 1.5#
N = 100#
#
poisd = dpois(1:10,lambda)#
binomd = dbinom(1:10,N,lambda/N)#
#
barplot(poisd)
barplot(rbind(poisd,binomd),beside=TRUE)
barplot(rbind(dpois(1:10,lambda),dbinom(1:10,N,lambda/N)),beside=TRUE)
lambda = 1.5
par(mfcol = c(3, 3))
par(mfcol = c(3, 3))#
for(i in seq(5,25,length.out=9)) {#
  barplot(rbind(dpois(1:10,lambda),dbinom(1:10,i,lambda/i)),beside=TRUE)#
}
par(mfcol = c(3, 3))#
for(i in seq(1,9,length.out=9)) {#
  barplot(rbind(dpois(1:10,lambda),dbinom(1:10,i,lambda/i)),beside=TRUE, main=)#
}
par(mfcol = c(3, 3))#
for(i in seq(2,10,length.out=9)) {#
  barplot(rbind(dpois(1:10,lambda),dbinom(1:10,i,lambda/i)),beside=TRUE, main=)#
}
par(mfcol = c(3, 3))#
for(i in seq(2,10,length.out=9)) {#
  barplot(rbind(dpois(1:10,lambda),dbinom(1:10,i,lambda/i)),#
          beside=TRUE, main=paste("N =",i))#
}
par(mfcol = c(3, 3))#
for(i in seq(2,19,length.out=9)) {#
  barplot(rbind(dpois(1:10,lambda),dbinom(1:10,i,lambda/i)),#
          beside=TRUE, main=paste("N =",i))#
}
par(mfcol = c(3, 3))#
for(i in seq(2,20,length.out=9)) {#
  barplot(rbind(dpois(1:10,lambda),dbinom(1:10,i,lambda/i)),#
          beside=TRUE, main=paste("N =",i))#
}
par(mfcol = c(3, 3))#
for(i in seq(2,20,by=2)) {#
  barplot(rbind(dpois(1:10,lambda),dbinom(1:10,i,lambda/i)),#
          beside=TRUE, main=paste("N =",i))#
}
par(mfcol = c(3, 3))#
for(i in seq(2,18,by=2)) {#
  barplot(rbind(dpois(1:10,lambda),dbinom(1:10,i,lambda/i)),#
          beside=TRUE, main=paste("N =",i))#
}
par(mfrow = c(3, 3))#
for(i in seq(2,18,by=2)) {#
  barplot(rbind(dpois(1:10,lambda),dbinom(1:10,i,lambda/i)),#
          beside=TRUE, main=paste("N =",i))#
}
par(mfrow = c(3, 3))#
for(i in seq(2,18,by=2)) {#
  barplot(rbind(dpois(1:10,lambda),dbinom(1:10,i,lambda/i)),#
          beside=FALSE, main=paste("N =",i))#
}
par(mfrow = c(3, 3))#
for(i in seq(2,18,by=2)) {#
  barplot(rbind(dpois(1:10,lambda),dbinom(1:10,i,lambda/i)),#
          beside=TRUE, main=paste("N =",i))#
}
#
par(mfrow = c(3, 3))#
for(i in seq(2,18,by=2)) {#
  barplot(rbind(dpois(1:10,lambda),dbinom(1:10,i,lambda/i)),#
          beside=TRUE, main=paste("N =",i), ylim+0.5)#
}
#
par(mfrow = c(3, 3))#
for(i in seq(2,18,by=2)) {#
  barplot(rbind(dpois(1:10,lambda),dbinom(1:10,i,lambda/i)),#
          beside=TRUE, main=paste("N =",i), ylim=0.5)#
}
par(mfrow = c(3, 3))#
for(i in seq(2,18,by=2)) {#
  barplot(rbind(dpois(1:10,lambda),dbinom(1:10,i,lambda/i)),#
          beside=TRUE, main=paste("N =",i), ylim=c(0,0.5))#
}
rm(list=lm())
rm(lm=list())
data
sum(data)
#
data=c(33,rep(0,25),rep(1,3),rep(2,2),rep(2,3),8,10,rep(0,19),12)#
#
negpoisloglike = function(lambda, data) {#
#Computes the negative log-likelihood of the inputted data under a poisson#
#distribution#
#data is a vector of integers#
#lambda is the mean value of the poission distribution#
  loglikelihoods = dpois(data,lambda,log=TRUE)  #calculate log likelihoods for each value#
  out = -sum(loglikelihoods)  #calculate the negative sum of log likelihoods#
  return(out)#
}#
#
optim(mean(data),negpoisloglike,method="BFGS")
data=c(33,rep(0,25),rep(1,3),rep(2,2),rep(2,3),8,10,rep(0,19),12)#
#
negpoisloglike = function(lambda, data) {#
#Computes the negative log-likelihood of the inputted data under a poisson#
#distribution#
#data is a vector of integers#
#lambda is the mean value of the poission distribution#
  loglikelihoods = dpois(data,lambda,log=TRUE)  #calculate log likelihoods for each value#
  out = -sum(loglikelihoods)  #calculate the negative sum of log likelihoods#
  return(out)#
}#
#
optim(mean(data),negpoisloglike,method="BFGS",data=data)
hist(data,n=24,col="red")
hist(data,n=24,col="red",freq=FALSE)
hist(data,n=24,col="red",freq=FALSE)#
ys = dpois(0:33,lambda=pois.fit$par)#
xs = 0:33#
points(xs,ys,type=both,col="blue")
#
data=c(33,rep(0,25),rep(1,3),rep(2,2),rep(2,3),8,10,rep(0,19),12)#
#
negpoisloglike = function(lambda, data) {#
#Computes the negative log-likelihood of the inputted data under a poisson#
#distribution#
#data is a vector of integers#
#lambda is the mean value of the poission distribution#
  loglikelihoods = dpois(data,lambda,log=TRUE)  #calculate log likelihoods for each value#
  out = -sum(loglikelihoods)  #calculate the negative sum of log likelihoods#
  return(out)#
}#
#
pois.fit = optim(mean(data),negpoisloglike,method="BFGS",data=data)  #find optimal fit#
#
hist(data,n=24,col="red",freq=FALSE)#
ys = dpois(0:33,lambda=pois.fit$par)#
xs = 0:33#
points(xs,ys,type=both,col="blue")
points(xs,ys,type="both",col="blue")
points(xs,ys,type="b",lwd=4)
rn
rn = dpois
rn
dbinom
dbinom(1, 5, 0.5)
list
list(5, 0.5)
z = list(5, 0.5)
dbinom(1, z)
z
z = as.list(prob=0.5, size=5)
z = as.list(c(prob=0.5, size=5))
z
dbinom(1, 5, 0.5)
dbinom(1,z)
args(dnbinom)
nargs(dnbinom)
nargs(dnbinom())
aargs(dnbinom())
args(dnbinom())
dbinom
formal(dnbinom)
formals(dnbinom)
names(formals(dnbinom))
z
dnbinom
dnbinom(1,z)
z = as.list(c(1, prob=0.5, size=5))
dnbinom(z)
z = as.list(c(x=1, prob=0.5, size=5))
dnbinom(z)
dbinom(1, 5, 0.5)
dnbnom(1,2,3)
dnbinom(1,2,0.3)
dnbinom(1,2,3)
dnbinom(1,2,0.3)
dnbinom(list(c(1,2,0.3)))
dnbinom(list(c(x=1,size=2,prob=0.3)))
list(c(x=1,size=2,prob=0.3))
as.list(c(x=1,size=2,prob=0.3))
dnbinom(as.list(c(x=1,size=2,prob=0.3)))
help(as.list)
as.list(c(a=1,b=2))
as.list(c(c=4,d=7))
y = as.list(c(a=1,b=2))
x = as.list(c(c=4,d=7))
z = c(x, y)
z
