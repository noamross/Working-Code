rm(list=ls()) #clear workspace#
#
#set parameters#
lambda = 20 #population growth coefficient#
a = 1 #intraspecific competition term#
d = 0.04 #dispersal coefficient#
p = 2 #number of patches#
#N0 = runif(p)*10 #initial conditions#
tf = 500 #number of time steps#
N0s = seq(0,lambda/exp(1),length.out=10) #vector of initial conditions to test#
#
#
#create dispersal matrix#
D = matrix(d/(p-1),p,p) #create disperal matrix with uniform dispersal#
diag(D) = 1-d#
#
N = matrix(0,tf,p) #create variable space for individual run outputs#
final.Ns = array(0, dim = c(rep(length(N0s), p), p))#
#
ricker.growth = function(N, lambda, a) { #density dependent growth function#
	N2 = lambda*N*exp(-a*N)#
	return(N2)#
	}#
#
#
for(k in 1:length(N0s)) {#
  for(j in 1:length(N0s)) {#
    N[1,] = c(N0s[j], N0s[k]) #set initial conditions from N0s#
#
    for(i in 1:(tf-1)) { #for each time i...#
    	N[i+1,] = D%*%ricker.growth(N[i,], lambda, a) #calculate next values of N#
    	}#
    	#
    final.Ns[k,j,] = N[tf,]#
    }#
  }
final.Ns
image(N0s,N0s,log(abs(final.Ns[,,1] - final.Ns[,,2])))
rm(list=ls()) #clear workspace#
#
#set parameters#
lambda = 20 #population growth coefficient#
a = 1 #intraspecific competition term#
d = 0.04 #dispersal coefficient#
p = 2 #number of patches#
#N0 = runif(p)*10 #initial conditions#
tf = 500 #number of time steps#
N0s = seq(0,lambda/exp(1),length.out=100) #vector of initial conditions to test#
#
#
#create dispersal matrix#
D = matrix(d/(p-1),p,p) #create disperal matrix with uniform dispersal#
diag(D) = 1-d#
#
N = matrix(0,tf,p) #create variable space for individual run outputs#
final.Ns = array(0, dim = c(rep(length(N0s), p), p))#
#
ricker.growth = function(N, lambda, a) { #density dependent growth function#
	N2 = lambda*N*exp(-a*N)#
	return(N2)#
	}#
#
#
for(k in 1:length(N0s)) {#
  for(j in 1:length(N0s)) {#
    N[1,] = c(N0s[j], N0s[k]) #set initial conditions from N0s#
#
    for(i in 1:(tf-1)) { #for each time i...#
    	N[i+1,] = D%*%ricker.growth(N[i,], lambda, a) #calculate next values of N#
    	}#
    	#
    final.Ns[k,j,] = N[tf,]#
    }#
  }#
#
image(N0s,N0s,log(abs(final.Ns[,,1] - final.Ns[,,2])))
stop
stop#
stop()
rm(list=ls()) #clear workspace#
#
#set parameters#
lambda = 20 #population growth coefficient#
a = 1 #intraspecific competition term#
d = 0.04 #dispersal coefficient#
p = 2 #number of patches#
#N0 = runif(p)*10 #initial conditions#
tf = 500 #number of time steps#
N0s = seq(0,lambda/exp(1),length.out=100) #vector of initial conditions to test#
#
#
#create dispersal matrix#
D = matrix(d/(p-1),p,p) #create disperal matrix with uniform dispersal#
diag(D) = 1-d#
#
N = matrix(0,tf,p) #create variable space for individual run outputs#
final.Ns = array(0, dim = c(rep(length(N0s), p), p))#
#
ricker.growth = function(N, lambda, a) { #density dependent growth function#
	N2 = lambda*N*exp(-a*N)#
	return(N2)#
	}#
#
#
for(k in 1:length(N0s)) {#
  for(j in 1:length(N0s)) {#
    N[1,] = c(N0s[j], N0s[k]) #set initial conditions from N0s#
#
    for(i in 1:(tf-1)) { #for each time i...#
    	N[i+1,] = D%*%ricker.growth(N[i,], lambda, a) #calculate next values of N#
    	}#
    	#
    final.Ns[k,j,] = N[tf,]#
    }#
  }#
#
image(N0s,N0s,log(abs(final.Ns[,,1] - final.Ns[,,2])))
help(system)
system("git add .")
system("git add .", intern=TRUE)
system(git add ., intern=TRUE)
system("git add .", intern=TRUE)
image(N0s,N0s,log(abs(final.Ns[,,1] - final.Ns[,,2])), col=rainbow(128),#
      xlab="Initial Population at Patch 1",#
      ylab="Inital Population at Patch 2",#
      main="Log Population Differences of Two Patches following Hastings 1990")
##
#
rm(list=ls()) #clear workspace#
#
#set parameters#
lambda = 20 #population growth coefficient#
a = 1 #intraspecific competition term#
d = 0.04 #dispersal coefficient#
p = 2 #number of patches#
#N0 = runif(p)*10 #initial conditions#
tf = 500 #number of time steps#
N0s = seq(0,lambda/exp(1),length.out=20) #vector of initial conditions to test#
#
#
#create dispersal matrix#
D = matrix(d/(p-1),p,p) #create disperal matrix with uniform dispersal#
diag(D) = 1-d#
#
N = matrix(0,tf,p) #create variable space for individual run outputs#
final.Ns = array(0, dim = c(rep(length(N0s), p), p))#
#
ricker.growth = function(N, lambda, a) { #density dependent growth function#
	N2 = lambda*N*exp(-a*N)#
	return(N2)#
	}#
#
#
for(k in 1:length(N0s)) {#
  for(j in 1:length(N0s)) {#
    N[1,] = c(N0s[j], N0s[k]) #set initial conditions from N0s#
#
    for(i in 1:(tf-1)) { #for each time i...#
    	N[i+1,] = D%*%ricker.growth(N[i,], lambda, a) #calculate next values of N#
    	}#
    	#
    final.Ns[k,j,] = N[tf,]#
    }#
  }#
#
image(N0s,N0s,log(abs(final.Ns[,,1] - final.Ns[,,2])), col=rainbow(128),#
      xlab="Initial Population at Patch 1",#
      ylab="Inital Population at Patch 2",#
      main="Log Population Differences of Two Patches following Hastings 1990")
save(final.Ns, file="Data/HastingsModelOut")
image(N0s,N0s,log(abs(final.Ns[,,1] - final.Ns[,,2])), col=rainbow(256),#
      xlab="Initial Population at Patch 1",#
      ylab="Inital Population at Patch 2",#
      main="Log Population Differences of Two Patches following Hastings 1990")
rm(list=ls()) #clear workspace
help(save)
save("Data/HastingsModelOut")
help(save)
load("Data/HastingsModelOut")
rm(list=ls()) #clear workspace
image(N0s,N0s,log(abs(final.Ns[,,1] - final.Ns[,,2])), col=rainbow(256),#
      xlab="Initial Population at Patch 1",#
      ylab="Inital Population at Patch 2",#
      main="Log Population Differences of Two Patches following Hastings 1990")
N0s = seq(0,lambda/exp(1),length.out=20) #vector of initial conditions to test
lambda = 20 #population growth coefficient#
a = 1 #intraspecific competition term#
d = 0.04 #dispersal coefficient#
p = 2 #number of patches#
#N0 = runif(p)*10 #initial conditions#
tf = 500 #number of time steps#
N0s = seq(0,lambda/exp(1),length.out=20) #vector of initial conditions to test
image(N0s,N0s,log(abs(final.Ns[,,1] - final.Ns[,,2])), col=rainbow(256),#
      xlab="Initial Population at Patch 1",#
      ylab="Inital Population at Patch 2",#
      main="Log Population Differences of Two Patches following Hastings 1990")
load("Data/HastingsModelOut.rdata")
load("Data/HastingsModelOut")
image(N0s,N0s,log(abs(final.Ns[,,1] - final.Ns[,,2])), col=rainbow(256),#
      xlab="Initial Population at Patch 1",#
      ylab="Inital Population at Patch 2",#
      main="Log Population Differences of Two Patches following Hastings 1990")
##
#
rm(list=ls()) #clear workspace#
#
#set parameters#
lambda = 20 #population growth coefficient#
a = 1 #intraspecific competition term#
d = 0.04 #dispersal coefficient#
p = 2 #number of patches#
#N0 = runif(p)*10 #initial conditions#
tf = 500 #number of time steps#
N0s = seq(0,lambda/exp(1),length.out=400) #vector of initial conditions to test#
#
#
#create dispersal matrix#
D = matrix(d/(p-1),p,p) #create disperal matrix with uniform dispersal#
diag(D) = 1-d#
#
N = matrix(0,tf,p) #create variable space for individual run outputs#
final.Ns = array(0, dim = c(rep(length(N0s), p), p))#
#
ricker.growth = function(N, lambda, a) { #density dependent growth function#
	N2 = lambda*N*exp(-a*N)#
	return(N2)#
	}#
#
#
for(k in 1:length(N0s)) {#
  for(j in 1:length(N0s)) {#
    N[1,] = c(N0s[j], N0s[k]) #set initial conditions from N0s#
#
    for(i in 1:(tf-1)) { #for each time i...#
    	N[i+1,] = D%*%ricker.growth(N[i,], lambda, a) #calculate next values of N#
    	}#
    	#
    final.Ns[k,j,] = N[tf,]#
    }#
  }#
#
save(final.Ns, file="Data/HastingsModelOut.rdata")#
image(N0s,N0s,log(abs(final.Ns[,,1] - final.Ns[,,2])), col=rainbow(256),#
      xlab="Initial Population at Patch 1",#
      ylab="Inital Population at Patch 2",#
      main="Log Population Differences of Two Patches following Hastings 1990")
Initial=c(5, 5, 10, 10, 15, 15, 20, 20, 30, 30, 50, 50, 75, 75, 100, 100)
data=c(33,rep(0,25),rep(1,3),rep(2,2),rep(2,3),8,10,rep(0,19),12)#
Initial=c(5, 5, 10, 10, 15, 15, 20, 20, 30, 30, 50, 50, 75, 75, 100, 100)#
Killed=c(1, 2, 5, 6, 10, 9, 7, 10, 11, 15, 5, 21, 32, 18, 25, 35)
data
flips = rbinom(1,24000,0.5)
sum(flips)
ave(flips)
flips
flips = rbinom(100,24000,0.5)
ave(flips)
flips
test = dbinom(12012,24000,0.5)
test
test2 = dbinom(11988:12012,24000,0.5)
test2
sum(test)
sum(test[1:25])
sum(test2)
data=c(33,rep(0,25),rep(1,3),rep(2,2),rep(2,3),8,10,rep(0,19),12)#
hist(data)
hist(data, breaks=1)
hist(data, breaks=40)
hist(data, breaks=length(data))
length(data)
hist(data,n=34)
poisd = dpois(1:100,lambda)#
binomd = dbinom(1:00,N,lambda/N)
lambda = 1.5#
N = 100#
#
poisd = dpois(1:100,lambda)#
binomd = dbinom(1:100,N,lambda/N)
barplot(poisd)
lambda = 1.5#
N = 100#
#
poisd = dpois(1:10,lambda)#
binomd = dbinom(1:10,N,lambda/N)#
#
barplot(poisd)
barplot(rbind(poisd,binomd),beside=TRUE)
barplot(rbind(dpois(1:10,lambda),dbinom(1:10,N,lambda/N)),beside=TRUE)
lambda = 1.5
par(mfcol = c(3, 3))
par(mfcol = c(3, 3))#
for(i in seq(5,25,length.out=9)) {#
  barplot(rbind(dpois(1:10,lambda),dbinom(1:10,i,lambda/i)),beside=TRUE)#
}
par(mfcol = c(3, 3))#
for(i in seq(1,9,length.out=9)) {#
  barplot(rbind(dpois(1:10,lambda),dbinom(1:10,i,lambda/i)),beside=TRUE, main=)#
}
par(mfcol = c(3, 3))#
for(i in seq(2,10,length.out=9)) {#
  barplot(rbind(dpois(1:10,lambda),dbinom(1:10,i,lambda/i)),beside=TRUE, main=)#
}
par(mfcol = c(3, 3))#
for(i in seq(2,10,length.out=9)) {#
  barplot(rbind(dpois(1:10,lambda),dbinom(1:10,i,lambda/i)),#
          beside=TRUE, main=paste("N =",i))#
}
par(mfcol = c(3, 3))#
for(i in seq(2,19,length.out=9)) {#
  barplot(rbind(dpois(1:10,lambda),dbinom(1:10,i,lambda/i)),#
          beside=TRUE, main=paste("N =",i))#
}
par(mfcol = c(3, 3))#
for(i in seq(2,20,length.out=9)) {#
  barplot(rbind(dpois(1:10,lambda),dbinom(1:10,i,lambda/i)),#
          beside=TRUE, main=paste("N =",i))#
}
par(mfcol = c(3, 3))#
for(i in seq(2,20,by=2)) {#
  barplot(rbind(dpois(1:10,lambda),dbinom(1:10,i,lambda/i)),#
          beside=TRUE, main=paste("N =",i))#
}
par(mfcol = c(3, 3))#
for(i in seq(2,18,by=2)) {#
  barplot(rbind(dpois(1:10,lambda),dbinom(1:10,i,lambda/i)),#
          beside=TRUE, main=paste("N =",i))#
}
par(mfrow = c(3, 3))#
for(i in seq(2,18,by=2)) {#
  barplot(rbind(dpois(1:10,lambda),dbinom(1:10,i,lambda/i)),#
          beside=TRUE, main=paste("N =",i))#
}
par(mfrow = c(3, 3))#
for(i in seq(2,18,by=2)) {#
  barplot(rbind(dpois(1:10,lambda),dbinom(1:10,i,lambda/i)),#
          beside=FALSE, main=paste("N =",i))#
}
par(mfrow = c(3, 3))#
for(i in seq(2,18,by=2)) {#
  barplot(rbind(dpois(1:10,lambda),dbinom(1:10,i,lambda/i)),#
          beside=TRUE, main=paste("N =",i))#
}
#
par(mfrow = c(3, 3))#
for(i in seq(2,18,by=2)) {#
  barplot(rbind(dpois(1:10,lambda),dbinom(1:10,i,lambda/i)),#
          beside=TRUE, main=paste("N =",i), ylim+0.5)#
}
#
par(mfrow = c(3, 3))#
for(i in seq(2,18,by=2)) {#
  barplot(rbind(dpois(1:10,lambda),dbinom(1:10,i,lambda/i)),#
          beside=TRUE, main=paste("N =",i), ylim=0.5)#
}
par(mfrow = c(3, 3))#
for(i in seq(2,18,by=2)) {#
  barplot(rbind(dpois(1:10,lambda),dbinom(1:10,i,lambda/i)),#
          beside=TRUE, main=paste("N =",i), ylim=c(0,0.5))#
}
rm(list=lm())
rm(lm=list())
data
sum(data)
#
data=c(33,rep(0,25),rep(1,3),rep(2,2),rep(2,3),8,10,rep(0,19),12)#
#
negpoisloglike = function(lambda, data) {#
#Computes the negative log-likelihood of the inputted data under a poisson#
#distribution#
#data is a vector of integers#
#lambda is the mean value of the poission distribution#
  loglikelihoods = dpois(data,lambda,log=TRUE)  #calculate log likelihoods for each value#
  out = -sum(loglikelihoods)  #calculate the negative sum of log likelihoods#
  return(out)#
}#
#
optim(mean(data),negpoisloglike,method="BFGS")
data=c(33,rep(0,25),rep(1,3),rep(2,2),rep(2,3),8,10,rep(0,19),12)#
#
negpoisloglike = function(lambda, data) {#
#Computes the negative log-likelihood of the inputted data under a poisson#
#distribution#
#data is a vector of integers#
#lambda is the mean value of the poission distribution#
  loglikelihoods = dpois(data,lambda,log=TRUE)  #calculate log likelihoods for each value#
  out = -sum(loglikelihoods)  #calculate the negative sum of log likelihoods#
  return(out)#
}#
#
optim(mean(data),negpoisloglike,method="BFGS",data=data)
hist(data,n=24,col="red")
hist(data,n=24,col="red",freq=FALSE)
hist(data,n=24,col="red",freq=FALSE)#
ys = dpois(0:33,lambda=pois.fit$par)#
xs = 0:33#
points(xs,ys,type=both,col="blue")
#
data=c(33,rep(0,25),rep(1,3),rep(2,2),rep(2,3),8,10,rep(0,19),12)#
#
negpoisloglike = function(lambda, data) {#
#Computes the negative log-likelihood of the inputted data under a poisson#
#distribution#
#data is a vector of integers#
#lambda is the mean value of the poission distribution#
  loglikelihoods = dpois(data,lambda,log=TRUE)  #calculate log likelihoods for each value#
  out = -sum(loglikelihoods)  #calculate the negative sum of log likelihoods#
  return(out)#
}#
#
pois.fit = optim(mean(data),negpoisloglike,method="BFGS",data=data)  #find optimal fit#
#
hist(data,n=24,col="red",freq=FALSE)#
ys = dpois(0:33,lambda=pois.fit$par)#
xs = 0:33#
points(xs,ys,type=both,col="blue")
points(xs,ys,type="both",col="blue")
points(xs,ys,type="b",lwd=4)
rn
rn = dpois
rn
dbinom
dbinom(1, 5, 0.5)
list
list(5, 0.5)
z = list(5, 0.5)
dbinom(1, z)
z
z = as.list(prob=0.5, size=5)
z = as.list(c(prob=0.5, size=5))
z
dbinom(1, 5, 0.5)
dbinom(1,z)
args(dnbinom)
nargs(dnbinom)
nargs(dnbinom())
aargs(dnbinom())
args(dnbinom())
dbinom
formal(dnbinom)
formals(dnbinom)
names(formals(dnbinom))
z
dnbinom
dnbinom(1,z)
z = as.list(c(1, prob=0.5, size=5))
dnbinom(z)
z = as.list(c(x=1, prob=0.5, size=5))
dnbinom(z)
dbinom(1, 5, 0.5)
dnbnom(1,2,3)
dnbinom(1,2,0.3)
dnbinom(1,2,3)
dnbinom(1,2,0.3)
dnbinom(list(c(1,2,0.3)))
dnbinom(list(c(x=1,size=2,prob=0.3)))
list(c(x=1,size=2,prob=0.3))
as.list(c(x=1,size=2,prob=0.3))
dnbinom(as.list(c(x=1,size=2,prob=0.3)))
help(as.list)
as.list(c(a=1,b=2))
as.list(c(c=4,d=7))
y = as.list(c(a=1,b=2))
x = as.list(c(c=4,d=7))
z = c(x, y)
z
data=c(33,rep(0,25),rep(1,3),rep(2,2),rep(2,3),8,10,rep(0,19),12) #create the data to fit
var(data)
mean(data)
data=c(33,rep(0,25),rep(1,3),rep(2,2),rep(2,3),8,10,rep(0,19),12) #create the data to fit#
nbprobguess = 1-(mean(data)/var(data)) # set initial guess for probability for neg-binomfit#
nbsizeguess = mean(data)*(1-nprobguess)/nprobguess #set initial guess for size for neg-binomfit#
nbiguess = as.list(c(prob=nbprobguess, size=nbsizeguess)) #initi
data=c(33,rep(0,25),rep(1,3),rep(2,2),rep(2,3),8,10,rep(0,19),12) #create the data to fit#
nbprobguess = 1-(mean(data)/var(data)) # set initial guess for probability for neg-binomfit#
nbsizeguess = mean(data)*(1-nbprobguess)/nbprobguess #set initial guess for size for neg-binomfit#
nbiguess = as.list(c(prob=nbprobguess, size=nbsizeguess)) #initial guesses for fit of neg-binomial distribution.  These are calulated
nbiguess
dnbinom(x,nbsizeguess,nbprobuess)
dnbinom(1,nbsizeguess,nbprobuess)
dnbinom(1,nbsizeguess,nbprobguess)
data=c(33,rep(0,25),rep(1,3),rep(2,2),rep(2,3),8,10,rep(0,19),12) #create the data to fit#
nbprobguess = 1-(mean(data)/var(data)) # set initial guess for probability for neg-binomfit#
nbsizeguess = mean(data)*(1-nbprobguess)/nbprobguess #set initial guess for size for neg-binomfit#
nbiguess = as.list(c(prob=nbprobguess, size=nbsizeguess)) #list of initial guesses for fit of neg-binomial distribution.  These are calulated
fitdiscdist(data,dnbinom,nbiguess)
#ECL 298 HW Week 6: Fitting Negative Binomial#
#Noam Ross, February 11, 2011#
#
fitdiscdist <- function(data, distpick, guesspars) {#
# This function fits a discrete probability distribution to a distribution of #
# data, using a maximum-likelihood method.#
# Arguments:#
#   data: a vector of integers representing the data to be fit#
#   distpick: the distribution to use to fit, e.g. dpois, dnbinom#
#   guesspars: a set of initial guesses for the distribution parameters, in the form#
#     of a list with names#
  optim.out = optim(guesspars, negloglike, method="BFGS",data=data, distpick=distpick) #run optimize function on negloglike function,#
  AIC = 2*optim.out$value + 2*length(guesspars) #calculate information criterion#
  out = as.list(pars=optim.out$par, likelihood=(-optim.out$value), AIC=AIC) #package outputs as list#
  return(out) #output the list#
}#
#
negloglike <- function(pars, data, distpick) {#
# This function calculates the negative log likelihood of data under a given function and parameters#
# Arguments:#
#   data: a vector of integers representing the data to be fit#
#   distpick: the distribution to use to fit, e.g. dpois, dnbinom#
#   pars: a set of initial guesses for the distribution parameters, in the form#
#     of a list with names#
  callparms = c(as.list(c(x=data,log=TRUE)), pars)  #create a unified list of arguments#
  loglikelihoods = do.call(distpick, callparms) #call the distribution function with those arguments#
  out = -sum(loglikelihoods)   #sum the loglikelihoods#
  return(out) #output the optimizing value#
#
}
fitdiscdist(data,dnbinom,nbiguess)
dnbinom(data,nbprobguess,nbsizeguess)
#ECL 298 HW Week 6: Fitting Negative Binomial#
#Noam Ross, February 11, 2011#
#
fitdiscdist <- function(data, distpick, guesspars) {#
# This function fits a discrete probability distribution to a distribution of #
# data, using a maximum-likelihood method.#
# Arguments:#
#   data: a vector of integers representing the data to be fit#
#   distpick: the distribution to use to fit, e.g. dpois, dnbinom#
#   guesspars: a set of initial guesses for the distribution parameters, in the form#
#     of a vector with names#
  optim.out = optim(guesspars, negloglike, method="BFGS",data=data, distpick=distpick) #run optimize function on negloglike function,#
  AIC = 2*optim.out$value + 2*length(guesspars) #calculate information criterion#
  out = as.list(pars=optim.out$par, likelihood=(-optim.out$value), AIC=AIC) #package outputs as list#
  return(out) #output the list#
}#
#
negloglike <- function(pars, data, distpick) {#
# This function calculates the negative log likelihood of data under a given function and parameters#
# Arguments:#
#   data: a vector of integers representing the data to be fit#
#   distpick: the distribution to use to fit, e.g. dpois, dnbinom#
#   pars: a set of initial guesses for the distribution parameters, in the form#
#     of a list with names#
  callparms = c(as.list(c(x=data,log=TRUE)), pars)  #create a unified list of arguments#
  loglikelihoods = do.call(distpick, callparms) #call the distribution function with those arguments#
  out = -sum(loglikelihoods)   #sum the loglikelihoods#
  return(out) #output the optimizing value#
#
}#
#
#Work session to #
data=c(33,rep(0,25),rep(1,3),rep(2,2),rep(2,3),8,10,rep(0,19),12) #create the data to fit#
nbprobguess = 1-(mean(data)/var(data)) # set initial guess for probability for neg-binomfit#
nbsizeguess = mean(data)*(1-nbprobguess)/nbprobguess #set initial guess for size for neg-binomfit#
nbiguess = c(prob=nbprobguess, size=nbsizeguess) #list of initial guesses for fit of neg-binomial distribution.  These are calulated #
fitdiscdist(data,dnbinom,nbiguess)
nbiguess
callparms = c(as.list(c(x=data,log=TRUE)), nbiguess)
callparms
callparms = (c(x=data,log=TRUEm, nbiguess))
callparms = (c(x=data,log=TRUE, nbiguess))
callparms
callparms = list(c(x=data,log=TRUE, nbiguess))
callparms
callparms = list(x=data,log=TRUE, nbiguess)
callparms
callparms = c(list(x=data,log=TRUE), as.list(nbiguess))
callparms
#ECL 298 HW Week 6: Fitting Negative Binomial#
#Noam Ross, February 11, 2011#
#
fitdiscdist <- function(data, distpick, guesspars) {#
# This function fits a discrete probability distribution to a distribution of #
# data, using a maximum-likelihood method.#
# Arguments:#
#   data: a vector of integers representing the data to be fit#
#   distpick: the distribution to use to fit, e.g. dpois, dnbinom#
#   guesspars: a set of initial guesses for the distribution parameters, in the form#
#     of a vector with names#
  optim.out = optim(guesspars, negloglike, method="BFGS",data=data, distpick=distpick) #run optimize function on negloglike function,#
  AIC = 2*optim.out$value + 2*length(guesspars) #calculate information criterion#
  out = as.list(pars=optim.out$par, likelihood=(-optim.out$value), AIC=AIC) #package outputs as list#
  return(out) #output the list#
}#
#
negloglike <- function(pars, data, distpick) {#
# This function calculates the negative log likelihood of data under a given function and parameters#
# Arguments:#
#   data: a vector of integers representing the data to be fit#
#   distpick: the distribution to use to fit, e.g. dpois, dnbinom#
#   pars: a set of initial guesses for the distribution parameters, in the form#
#     of a list with names#
  callparms = c(list(x=data,log=TRUE), as.list(pars))  #create a unified list of arguments#
  loglikelihoods = do.call(distpick, callparms) #call the distribution function with those arguments#
  out = -sum(loglikelihoods)   #sum the loglikelihoods#
  return(out) #output the optimizing value#
#
}#
#
#Work session to #
data=c(33,rep(0,25),rep(1,3),rep(2,2),rep(2,3),8,10,rep(0,19),12) #create the data to fit#
nbprobguess = 1-(mean(data)/var(data)) # set initial guess for probability for neg-binomfit#
nbsizeguess = mean(data)*(1-nbprobguess)/nbprobguess #set initial guess for size for neg-binomfit#
nbiguess = c(prob=nbprobguess, size=nbsizeguess) #list of initial guesses for fit of neg-binomial distribution.  These are calulated #
fitdiscdist(data,dnbinom,nbiguess)
warning()
warnings()
nbiguess
callparms = c(list(x=data,log=TRUE), as.list(nbiguess))
callparms
loglikelihoods = do.call(dnbinom, callparms)
loglikelihoods
out = -sum(loglikelihoods)
out
dnbinom(data,nbsizeguess,nbprobguess,log=TRUE)
#ECL 298 HW Week 6: Fitting Negative Binomial#
#Noam Ross, February 11, 2011#
#
fitdiscdist <- function(data, distpick, guesspars) {#
# This function fits a discrete probability distribution to a distribution of #
# data, using a maximum-likelihood method.#
# Arguments:#
#   data: a vector of integers representing the data to be fit#
#   distpick: the distribution to use to fit, e.g. dpois, dnbinom#
#   guesspars: a set of initial guesses for the distribution parameters, in the form#
#     of a vector with names#
  optim.out = optim(guesspars, negloglike, method="BFGS",data=data, distpick=distpick) #run optimize function on negloglike function,#
  AIC = 2*optim.out$value + 2*length(guesspars) #calculate information criterion#
  out = as.list(pars=optim.out$par, likelihood=(-optim.out$value), AIC=AIC) #package outputs as list#
  return(out) #output the list#
}#
#
negloglike <- function(pars, data, distpick) {#
# This function calculates the negative log likelihood of data under a given function and parameters#
# Arguments:#
#   data: a vector of integers representing the data to be fit#
#   distpick: the distribution to use to fit, e.g. dpois, dnbinom#
#   pars: a set of initial guesses for the distribution parameters, in the form#
#     of a list with names#
  callparms = c(list(x=data,log=TRUE), as.list(pars))  #create a unified list of arguments#
  loglikelihoods = do.call(distpick, callparms) #call the distribution function with those arguments#
  out = -sum(loglikelihoods)   #sum the loglikelihoods#
  return(out) #output the optimizing value#
#
}
nbiguess
optim(nbiguess, negloglike, method="BFGS", data=data, distpick=dnbinom)
#ECL 298 HW Week 6: Fitting Negative Binomial#
#Noam Ross, February 11, 2011#
#
fitdiscdist <- function(data, distpick, guesspars) {#
# This function fits a discrete probability distribution to a distribution of #
# data, using a maximum-likelihood method.#
# Arguments:#
#   data: a vector of integers representing the data to be fit#
#   distpick: the distribution to use to fit, e.g. dpois, dnbinom#
#   guesspars: a set of initial guesses for the distribution parameters, in the form#
#     of a vector with names#
  optim.out = optim(guesspars, negloglike, method="BFGS",data=data, distpick=distpick) #run optimize function on negloglike function,#
  AIC = 2*optim.out$value + 2*length(guesspars) #calculate information criterion#
  out = as.list(pars=optim.out$par, likelihood=(-optim.out$value), AIC=AIC) #package outputs as list#
  return(out) #output the list#
}#
#
negloglike <- function(pars, data, distpick) {#
# This function calculates the negative log likelihood of data under a given function and parameters#
# Arguments:#
#   data: a vector of integers representing the data to be fit#
#   distpick: the distribution to use to fit, e.g. dpois, dnbinom#
#   pars: a set of initial guesses for the distribution parameters, in the form#
#     of a list with names#
  callparms = c(list(x=data,log=TRUE), as.list(pars))  #create a unified list of arguments#
  loglikelihoods = do.call(distpick, callparms) #call the distribution function with those arguments#
  out = -sum(loglikelihoods)   #sum the loglikelihoods#
  return(out) #output the optimizing value#
#
}#
#
#Work session to #
data=c(33,rep(0,25),rep(1,3),rep(2,2),rep(2,3),8,10,rep(0,19),12) #create the data to fit#
nbprobguess = 1-(mean(data)/var(data)) # set initial guess for probability for neg-binomfit#
nbsizeguess = mean(data)*(1-nbprobguess)/nbprobguess #set initial guess for size for neg-binomfit#
nbiguess = c(prob=nbprobguess, size=nbsizeguess) #list of initial guesses for fit of neg-binomial distribution.  These are calulated #
fitdiscdist(data,dnbinom,nbiguess)
optim(nbiguess, negloglike, method="BFGS", data=data, distpick=dnbinom)
optim.out = optim(nbiguess, negloglike, method="BFGS", data=data, distpick=dnbinom)
optim.out
AIC = 2*optim.out$value + 2*length(nbiguess)
AIC
out = as.list(pars=optim.out$par, likelihood=(-optim.out$value), AIC=AIC)
out = list(pars=optim.out$par, likelihood=(-optim.out$value), AIC=AIC)
out
#ECL 298 HW Week 6: Fitting Negative Binomial#
#Noam Ross, February 11, 2011#
#
fitdiscdist <- function(data, distpick, guesspars) {#
# This function fits a discrete probability distribution to a distribution of #
# data, using a maximum-likelihood method.#
# Arguments:#
#   data: a vector of integers representing the data to be fit#
#   distpick: the distribution to use to fit, e.g. dpois, dnbinom#
#   guesspars: a set of initial guesses for the distribution parameters, in the form#
#     of a vector with names#
  optim.out = optim(guesspars, negloglike, method="BFGS",data=data, distpick=distpick) #run optimize function on negloglike function,#
  AIC = 2*optim.out$value + 2*length(guesspars) #calculate information criterion#
  out = list(pars=optim.out$par, likelihood=(-optim.out$value), AIC=AIC) #package outputs as list#
  return(out) #output the list#
}#
#
negloglike <- function(pars, data, distpick) {#
# This function calculates the negative log likelihood of data under a given function and parameters#
# Arguments:#
#   data: a vector of integers representing the data to be fit#
#   distpick: the distribution to use to fit, e.g. dpois, dnbinom#
#   pars: a set of initial guesses for the distribution parameters, in the form#
#     of a list with names#
  callparms = c(list(x=data,log=TRUE), as.list(pars))  #create a unified list of arguments#
  loglikelihoods = do.call(distpick, callparms) #call the distribution function with those arguments#
  out = -sum(loglikelihoods)   #sum the loglikelihoods#
  return(out) #output the optimizing value#
#
}#
#
#Work session to #
data=c(33,rep(0,25),rep(1,3),rep(2,2),rep(2,3),8,10,rep(0,19),12) #create the data to fit#
nbprobguess = 1-(mean(data)/var(data)) # set initial guess for probability for neg-binomfit#
nbsizeguess = mean(data)*(1-nbprobguess)/nbprobguess #set initial guess for size for neg-binomfit#
nbiguess = c(prob=nbprobguess, size=nbsizeguess) #list of initial guesses for fit of neg-binomial distribution.  These are calulated #
fitdiscdist(data,dnbinom,nbiguess)
nbinomrun = fitdiscdist(data,dnbinom,nbiguess) #fit the data to a negative binomial distribution
poisrun = fitdiscdist(data,dpois,mean(data) #fit the data to a poisson distribution
)
poisrun
hist(data,n=24,col="red",freq=FALSE)
nbinomrun
nbinomrun$par
nbinomrun$par[size]
nbinomrun$par[1]
nbinomrun$par['size']
pys = dpois(0:33,lambda=poisrun$par)#
dnys = dnbinom(0:33,size=nbinomrun$par['size'],prob=nbinomrun$par['prob'])#
xs = 0:33#
lines(xs,pys,col="green",lwd=4)#
lines(xs,dnys,col="blue",lwd=4)
hist(data,n=24,col="red",freq=FALSE)#
pys = dpois(0:33,lambda=poisrun$par)#
dnys = dnbinom(0:33,size=nbinomrun$par['size'],prob=nbinomrun$par['prob'])#
xs = 0:33#
lines(xs,pys,col="green",lwd=2)#
lines(xs,dnys,col="blue",lwd=2)
legend(20,0.6,[paste("Poisson (AIC = ",poisrun$AIC,")")])
legend(20,0.6,c(paste("Poisson (AIC = ",poisrun$AIC,")"),paste("Neg-Binom (AIC = ",nbinomrun$AIC,")")))
hist(data,n=24,col="red",freq=FALSE, main = Poisson and Negative Binomial Fits to SARS Data)#
pys = dpois(0:33,lambda=poisrun$par)#
dnys = dnbinom(0:33,size=nbinomrun$par['size'],prob=nbinomrun$par['prob'])#
xs = 0:33#
lines(xs,pys,col="green",lwd=2)#
lines(xs,dnys,col="blue",lwd=2)#
legend(20,0.6,c(paste("Poisson (AIC = ",round(poisrun$AIC,1),")"),#
       paste("Neg-Binom (AIC = ",round(nbinomrun$AIC,1),")")))
hist(data,n=24,col="red",freq=FALSE, main="Poisson and Negative Binomial Fits to SARS Data")#
pys = dpois(0:33,lambda=poisrun$par)#
dnys = dnbinom(0:33,size=nbinomrun$par['size'],prob=nbinomrun$par['prob'])#
xs = 0:33#
lines(xs,pys,col="green",lwd=2)#
lines(xs,dnys,col="blue",lwd=2)#
legend(20,0.6,c(paste("Poisson (AIC = ",round(poisrun$AIC,1),")"),#
       paste("Neg-Binom (AIC = ",round(nbinomrun$AIC,1),")")))
hist(data,n=24,col="red",freq=FALSE, main="Poisson and Negative Binomial Fits to SARS Data")#
pys = dpois(0:33,lambda=poisrun$par)#
dnys = dnbinom(0:33,size=nbinomrun$par['size'],prob=nbinomrun$par['prob'])#
xs = 0:33#
lines(xs,pys,col="green",lwd=2)#
lines(xs,dnys,col="blue",lwd=2)#
legend(20,0.6,c(paste("Poisson (AIC = ",round(poisrun$AIC,1),")"),#
       paste("Neg-Binom (AIC = ",round(nbinomrun$AIC,1),")"))), col=c("green","blue"))
legend(20,0.6,c(paste("Poisson (AIC = ",round(poisrun$AIC,1),")"),#
       paste("Neg-Binom (AIC = ",round(nbinomrun$AIC,1),")")), col=c("green","blue"))
#
hist(data,n=24,col="red",freq=FALSE, main="Poisson and Negative Binomial Fits to SARS Data")#
pys = dpois(0:33,lambda=poisrun$par)#
dnys = dnbinom(0:33,size=nbinomrun$par['size'],prob=nbinomrun$par['prob'])#
xs = 0:33#
lines(xs,pys,col="green",lwd=2)#
lines(xs,dnys,col="blue",lwd=2)#
legend(15,0.6,c(paste("Poisson (AIC = ",round(poisrun$AIC,1),")"),#
       paste("Neg-Binom (AIC = ",round(nbinomrun$AIC,1),")")), col=c("green","blue"))
legend(15,0.6,c(paste("Poisson (AIC = ",round(poisrun$AIC,1),")"),#
       paste("Neg-Binom (AIC = ",round(nbinomrun$AIC,1),")")), col=c("green","blue"),#
       lty=c("solid,solid"))
#
hist(data,n=24,col="red",freq=FALSE, main="Poisson and Negative Binomial Fits to SARS Data")#
pys = dpois(0:33,lambda=poisrun$par)#
dnys = dnbinom(0:33,size=nbinomrun$par['size'],prob=nbinomrun$par['prob'])#
xs = 0:33#
lines(xs,pys,col="green",lwd=2)#
lines(xs,dnys,col="blue",lwd=2)#
legend(10,0.6,c(paste("Poisson (AIC = ",round(poisrun$AIC,2),")"),#
       paste("Neg-Binom (AIC = ",round(nbinomrun$AIC,2),")")), col=c("green","blue"),#
       lty=c("solid,solid"))
hist(data,n=24,col="red",freq=FALSE, main="Poisson and Negative Binomial Fits to SARS Data")#
pys = dpois(0:33,lambda=poisrun$par)#
dnys = dnbinom(0:33,size=nbinomrun$par['size'],prob=nbinomrun$par['prob'])#
xs = 0:33#
lines(xs,pys,col="green",lwd=2)#
lines(xs,dnys,col="blue",lwd=2)#
legend(10,0.6,c(paste("Poisson (AIC = ",round(poisrun$AIC,2),")"),#
       paste("Neg-Binom (AIC = ",round(nbinomrun$AIC,2),")")), col=c("green","blue"),#
       lty=c("solid,solid"))
hist(data,n=24,col="red",freq=FALSE, main="Poisson and Negative Binomial Fits to SARS Data")#
pys = dpois(0:33,lambda=poisrun$par)#
dnys = dnbinom(0:33,size=nbinomrun$par['size'],prob=nbinomrun$par['prob'])#
xs = 0:33#
lines(xs,pys,col="green",lwd=2)#
lines(xs,dnys,col="blue",lwd=2)#
legend(15,0.6,c(paste("Poisson (AIC = ",round(poisrun$AIC,2),")"),#
       paste("Neg-Binom (AIC = ",round(nbinomrun$AIC,2),")")), col=c("green","blue"),#
       lty=c("solid,solid"))
legend(15,0.6,c(paste("Poisson (AIC = ",round(poisrun$AIC,2),")"),#
       paste("Neg-Binom (AIC = ",round(nbinomrun$AIC,2),")")), col=c("green","blue"),#
       )
leg.txt <- c("Setosa     Petals", "Setosa     Sepals",#
             "Versicolor Petals", "Versicolor Sepals")#
y.leg <- c(4.5, 3, 2.1, 1.4, .7)#
cexv  <- c(1.2, 1, 4/5, 2/3, 1/2)#
matplot(c(1,8), c(0,4.5), type = "n", xlab = "Length", ylab = "Width",#
        main = "Petal and Sepal Dimensions in Iris Blossoms")#
for (i in seq(cexv)) {#
  text  (1, y.leg[i]-.1, paste("cex=",formatC(cexv[i])), cex=.8, adj = 0)#
  legend(3, y.leg[i], leg.txt, pch = "sSvV", col = c(1, 3), cex = cexv[i])#
}
x <- seq(-pi, pi, len = 65)#
plot(x, sin(x), type = "l", ylim = c(-1.2, 1.8), col = 3, lty = 2)#
points(x, cos(x), pch = 3, col = 4)#
lines(x, tan(x), type = "b", lty = 1, pch = 4, col = 6)#
title("legend(..., lty = c(2, -1, 1), pch = c(-1,3,4), merge = TRUE)",#
      cex.main = 1.1)#
legend(-1, 1.9, c("sin", "cos", "tan"), col = c(3,4,6),#
       text.col = "green4", lty = c(2, -1, 1), pch = c(-1, 3, 4),#
       merge = TRUE, bg = 'gray90')
data=c(33,rep(0,25),rep(1,3),rep(2,2),rep(2,3),8,10,rep(0,19),12) #create the data to fit#
nbprobguess = 1-(mean(data)/var(data)) # set initial guess for probability for neg-binomfit#
nbsizeguess = mean(data)*(1-nbprobguess)/nbprobguess #set initial guess for size for neg-binomfit#
nbiguess = c(prob=nbprobguess, size=nbsizeguess) #list of initial guesses for fit of neg-binomial distribution.  These are calulated #
#
nbinomrun = fitdiscdist(data,dnbinom,nbiguess) #fit the data to a negative binomial distribution#
poisrun = fitdiscdist(data,dpois,mean(data)) #fit the data to a poisson distribution#
#
hist(data,n=24,col="red",freq=FALSE, main="Poisson and Negative Binomial Fits to SARS Data")#
pys = dpois(0:33,lambda=poisrun$par)#
dnys = dnbinom(0:33,size=nbinomrun$par['size'],prob=nbinomrun$par['prob'])#
xs = 0:33#
lines(xs,pys,col="green",lwd=2)#
lines(xs,dnys,col="blue",lwd=2)#
legend(15,0.6,c(paste("Poisson (AIC = ",round(poisrun$AIC,2),")"),#
       paste("Neg-Binom (AIC = ",round(nbinomrun$AIC,2),")")), col=c(1,2), lty=c(1,1)#
       )
legend(15,0.6,c(paste("Poisson (AIC = ",round(poisrun$AIC,2),")"),#
       paste("Neg-Binom (AIC = ",round(nbinomrun$AIC,2),")")), col=c(1,2), lty=c(2,2)#
       )
legend(15,0.6,c(paste("Poisson (AIC = ",round(poisrun$AIC,2),")"),#
       paste("Neg-Binom (AIC = ",round(nbinomrun$AIC,2),")")), col=c("green","blue"), lty=c(2,2)#
       )
data=c(33,rep(0,25),rep(1,3),rep(2,2),rep(2,3),8,10,rep(0,19),12) #create the data to fit#
nbprobguess = 1-(mean(data)/var(data)) # set initial guess for probability for neg-binomfit#
nbsizeguess = mean(data)*(1-nbprobguess)/nbprobguess #set initial guess for size for neg-binomfit#
nbiguess = c(prob=nbprobguess, size=nbsizeguess) #list of initial guesses for fit of neg-binomial distribution.  These are calulated #
#
nbinomrun = fitdiscdist(data,dnbinom,nbiguess) #fit the data to a negative binomial distribution#
poisrun = fitdiscdist(data,dpois,mean(data)) #fit the data to a poisson distribution#
#
hist(data,n=24,col="red",freq=FALSE, main="Poisson and Negative Binomial Fits to SARS Data")#
pys = dpois(0:33,lambda=poisrun$par)#
dnys = dnbinom(0:33,size=nbinomrun$par['size'],prob=nbinomrun$par['prob'])#
xs = 0:33#
lines(xs,pys,col="green",lwd=2)#
lines(xs,dnys,col="blue",lwd=2)#
legend(15,0.6,c(paste("Poisson (AIC = ",round(poisrun$AIC,2),")"),#
       paste("Neg-Binom (AIC = ",round(nbinomrun$AIC,2),")")), col=c("green","blue"), #
       lty=c(1,1))
#ECL 298 HW Week 6: Fitting Negative Binomial#
#Noam Ross, February 11, 2011#
#
fitdiscdist <- function(data, distpick, guesspars) {#
# This function fits a discrete probability distribution to a distribution of #
# data, using a maximum-likelihood method.#
# Arguments:#
#   data: a vector of integers representing the data to be fit#
#   distpick: the distribution to use to fit, e.g. dpois, dnbinom#
#   guesspars: a set of initial guesses for the distribution parameters, in the form#
#     of a vector with names#
  optim.out = optim(guesspars, negloglike, method="BFGS",data=data, distpick=distpick) #run optimize function on negloglike function,#
  AIC = 2*length(guesspars) + 2*optim.out$value #calculate information criterion#
  out = list(pars=optim.out$par, likelihood=(-optim.out$value), AIC=AIC) #package outputs as list#
  return(out) #output the list#
}#
#
negloglike <- function(pars, data, distpick) {#
# This function calculates the negative log likelihood of data under a given function and parameters#
# Arguments:#
#   data: a vector of integers representing the data to be fit#
#   distpick: the distribution to use to fit, e.g. dpois, dnbinom#
#   pars: a set of initial guesses for the distribution parameters, in the form#
#     of a list with names#
  callparms = c(list(x=data,log=TRUE), as.list(pars))  #create a unified list of arguments#
  loglikelihoods = do.call(distpick, callparms) #call the distribution function with those arguments#
  out = -sum(loglikelihoods)   #sum the loglikelihoods#
  return(out) #output the optimizing value#
#
}#
#
#Work session to fit data#
data=c(33,rep(0,25),rep(1,3),rep(2,2),rep(2,3),8,10,rep(0,19),12) #create the data to fit#
nbprobguess = 1-(mean(data)/var(data)) # set initial guess for probability for neg-binomfit#
nbsizeguess = mean(data)*(1-nbprobguess)/nbprobguess #set initial guess for size for neg-binomfit#
nbiguess = c(prob=nbprobguess, size=nbsizeguess) #list of initial guesses for fit of neg-binomial distribution.  These are calulated #
#
nbinomrun = fitdiscdist(data,dnbinom,nbiguess) #fit the data to a negative binomial distribution#
poisrun = fitdiscdist(data,dpois,mean(data)) #fit the data to a poisson distribution#
#
hist(data,n=24,col="red",freq=FALSE, main="Poisson and Negative Binomial Fits to SARS Data"#
     xlab="Number of Infections",ylab="Proportion of Cases")#
pys = dpois(0:33,lambda=poisrun$par)#
dnys = dnbinom(0:33,size=nbinomrun$par['size'],prob=nbinomrun$par['prob'])#
xs = 0:33#
lines(xs,pys,col="green",lwd=2)#
lines(xs,dnys,col="blue",lwd=2)#
legend(15,0.6,c(paste("Poisson (AIC = ",round(poisrun$AIC,2),")"),#
       paste("Neg-Binom (AIC = ",round(nbinomrun$AIC,2),")")), col=c("green","blue"), #
       lty=c(1,1))
hist(data,n=24,col="red",freq=FALSE, main="Poisson and Negative Binomial Fits to SARS Data"#
     xlab="Number of Infections",ylab="Proportion of Cases")#
pys = dpois(0:33,lambda=poisrun$par)#
dnys = dnbinom(0:33,size=nbinomrun$par['size'],prob=nbinomrun$par['prob'])#
xs = 0:33#
lines(xs,pys,col="green",lwd=2)#
lines(xs,dnys,col="blue",lwd=2)#
legend(15,0.6,c(paste("Poisson (AIC = ",round(poisrun$AIC,2),")"),#
       paste("Neg-Binom (AIC = ",round(nbinomrun$AIC,2),")")), col=c("green","blue"), #
       lty=c(1,1))
rm(list=ls())
#ECL 298 HW Week 6: Fitting Negative Binomial#
#Noam Ross, February 11, 2011#
#
fitdiscdist <- function(data, distpick, guesspars) {#
# This function fits a discrete probability distribution to a distribution of #
# data, using a maximum-likelihood method.#
# Arguments:#
#   data: a vector of integers representing the data to be fit#
#   distpick: the distribution to use to fit, e.g. dpois, dnbinom#
#   guesspars: a set of initial guesses for the distribution parameters, in the form#
#     of a vector with names#
  optim.out = optim(guesspars, negloglike, method="BFGS",data=data, distpick=distpick) #run optimize function on negloglike function,#
  AIC = 2*length(guesspars) + 2*optim.out$value #calculate information criterion#
  out = list(pars=optim.out$par, likelihood=(-optim.out$value), AIC=AIC) #package outputs as list#
  return(out) #output the list#
}#
#
negloglike <- function(pars, data, distpick) {#
# This function calculates the negative log likelihood of data under a given function and parameters#
# Arguments:#
#   data: a vector of integers representing the data to be fit#
#   distpick: the distribution to use to fit, e.g. dpois, dnbinom#
#   pars: a set of initial guesses for the distribution parameters, in the form#
#     of a list with names#
  callparms = c(list(x=data,log=TRUE), as.list(pars))  #create a unified list of arguments#
  loglikelihoods = do.call(distpick, callparms) #call the distribution function with those arguments#
  out = -sum(loglikelihoods)   #sum the loglikelihoods#
  return(out) #output the optimizing value#
#
}
data=c(33,rep(0,25),rep(1,3),rep(2,2),rep(2,3),8,10,rep(0,19),12) #create the data to fit#
nbprobguess = 1-(mean(data)/var(data)) # set initial guess for probability for neg-binomfit#
nbsizeguess = mean(data)*(1-nbprobguess)/nbprobguess #set initial guess for size for neg-binomfit#
nbiguess = c(prob=nbprobguess, size=nbsizeguess) #list of initial guesses for fit of neg-binomial distribution.  These are calulated #
#
nbinomrun = fitdiscdist(data,dnbinom,nbiguess) #fit the data to a negative binomial distribution#
poisrun = fitdiscdist(data,dpois,mean(data)) #fit the data to a poisson distribution
hist(data,n=24,col="red",freq=FALSE, main="Poisson and Negative Binomial Fits to SARS Data"#
     xlab="Number of Infections",ylab="Proportion of Cases")#
pys = dpois(0:33,lambda=poisrun$par)#
dnys = dnbinom(0:33,size=nbinomrun$par['size'],prob=nbinomrun$par['prob'])#
xs = 0:33#
lines(xs,pys,col="green",lwd=2)#
lines(xs,dnys,col="blue",lwd=2)#
legend(15,0.6,c(paste("Poisson (AIC = ",round(poisrun$AIC,2),")"),#
       paste("Neg-Binom (AIC = ",round(nbinomrun$AIC,2),")")), col=c("green","blue"), #
       lty=c(1,1))
hist(data,n=24,col="red",freq=FALSE, main="Poisson and Negative Binomial Fits to SARS Data"#
     xlab="Number of Infections",ylab="Proportion of Cases")
hist(data,n=24,col="red",freq=FALSE, main="Poisson and Negative Binomial Fits to SARS Data",#
     xlab="Number of Infections",ylab="Proportion of Cases")#
pys = dpois(0:33,lambda=poisrun$par)#
dnys = dnbinom(0:33,size=nbinomrun$par['size'],prob=nbinomrun$par['prob'])#
xs = 0:33#
lines(xs,pys,col="green",lwd=2)#
lines(xs,dnys,col="blue",lwd=2)#
legend(15,0.6,c(paste("Poisson (AIC = ",round(poisrun$AIC,2),")"),#
       paste("Neg-Binom (AIC = ",round(nbinomrun$AIC,2),")")), col=c("green","blue"), #
       lty=c(1,1))
#ECL 298 HW Week 6: Fitting Negative Binomial#
#Noam Ross, February 11, 2011#
#
fitdiscdist <- function(data, distpick, guesspars) {#
# This function fits a discrete probability distribution to a distribution of #
# data, using a maximum-likelihood method.#
# Arguments:#
#   data: a vector of integers representing the data to be fit#
#   distpick: the distribution to use to fit, e.g. dpois, dnbinom#
#   guesspars: a set of initial guesses for the distribution parameters, in the form#
#     of a vector with names#
  optim.out = optim(guesspars, negloglike, method="BFGS",data=data, distpick=distpick) #run optimize function on negloglike function,#
  AIC = 2*length(guesspars) + 2*optim.out$value #calculate information criterion#
  out = list(pars=optim.out$par, likelihood=(-optim.out$value), AIC=AIC) #package outputs as list#
  return(out) #output the list#
}#
#
negloglike <- function(pars, data, distpick) {#
# This function calculates the negative log likelihood of data under a given function and parameters#
# Arguments:#
#   data: a vector of integers representing the data to be fit#
#   distpick: the distribution to use to fit, e.g. dpois, dnbinom#
#   pars: a set of initial guesses for the distribution parameters, in the form#
#     of a list with names#
  callparms = c(list(x=data,log=TRUE), as.list(pars))  #create a unified list of arguments#
  loglikelihoods = do.call(distpick, callparms) #call the distribution function with those arguments#
  out = -sum(loglikelihoods)   #sum the loglikelihoods#
  return(out) #output the optimizing value#
#
}#
#
#Work session to fit data#
data=c(33,rep(0,25),rep(1,3),rep(2,2),rep(2,3),8,10,rep(0,19),12) #create the data to fit#
nbprobguess = 1-(mean(data)/var(data)) # set initial guess for probability for neg-binomfit#
nbsizeguess = mean(data)*(1-nbprobguess)/nbprobguess #set initial guess for size for neg-binomfit#
nbiguess = c(prob=nbprobguess, size=nbsizeguess) #list of initial guesses for fit of neg-binomial distribution.  These are calulated #
#
nbinomrun = fitdiscdist(data,dnbinom,nbiguess) #fit the data to a negative binomial distribution#
poisrun = fitdiscdist(data,dpois,mean(data)) #fit the data to a poisson distribution#
#
hist(data,n=24,col="red",freq=FALSE, main="Poisson and Negative Binomial Fits to SARS Data",#
     xlab="Number of Infections",ylab="Proportion of Cases")#
pys = dpois(0:33,lambda=poisrun$par)#
dnys = dnbinom(0:33,size=nbinomrun$par['size'],prob=nbinomrun$par['prob'])#
xs = 0:33#
lines(xs,pys,col="green",lwd=2)#
lines(xs,dnys,col="blue",lwd=2)#
legend(15,0.6,c(paste("Poisson (AIC = ",round(poisrun$AIC,2),")"),#
       paste("Neg-Binom (AIC = ",round(nbinomrun$AIC,2),")")), col=c("green","blue"), #
       lty=c(1,1))
nbinomrun
nbprobguess = 1-(mean(data)/var(data))
nbprobguess
nbsizeguess
x = c(1,2,3)
x
x = c(5,7,9)
x
x[2]
rbinomrun
nbinomrun
nbsizeguess
nbprobguess
dnbinom(1:100,prob=0.5,size=5)
y = dnbinom(1:100,prob=0.5,size=5)
x = 1:1000
x=1:100
plot(x,y)
bars(x,y)
barplot(x,y)
plot(x,y)
y = dnbinom(1:100,prob=0.5,size=20)
plot(x,y)
#ECL 298 HW Week 6: Fitting Negative Binomial#
#Noam Ross, February 11, 2011#
#
fitdiscdist <- function(data, distpick, guesspars) {#
# This function fits a discrete probability distribution to a distribution of #
# data, using a maximum-likelihood method.#
# Arguments:#
#   data: a vector of integers representing the data to be fit#
#   distpick: the distribution to use to fit, e.g. dpois, dnbinom#
#   guesspars: a set of initial guesses for the distribution parameters, in the form#
#     of a vector with names#
  optim.out = optim(guesspars, negloglike, method="BFGS",data=data, distpick=distpick) #run optimize function on negloglike function,#
  AIC = 2*length(guesspars) + 2*optim.out$value #calculate information criterion#
  out = list(pars=optim.out$par, likelihood=(-optim.out$value), AIC=AIC) #package outputs as list#
  return(out) #output the list#
}#
#
negloglike <- function(pars, data, distpick) {#
# This function calculates the negative log likelihood of data under a given function and parameters#
# Arguments:#
#   data: a vector of integers representing the data to be fit#
#   distpick: the distribution to use to fit, e.g. dpois, dnbinom#
#   pars: a set of initial guesses for the distribution parameters, in the form#
#     of a list with names#
  callparms = c(list(x=data,log=TRUE), as.list(pars))  #create a unified list of arguments#
  loglikelihoods = do.call(distpick, callparms) #call the distribution function with those arguments#
  out = -sum(loglikelihoods)   #sum the loglikelihoods#
  return(out) #output the optimizing value#
#
}#
#
#Work session to fit data#
data=c(33,rep(0,25),rep(1,3),rep(2,2),rep(2,3),8,10,rep(0,19),12) #create the data to fit#
nbprobguess = 1-(mean(data)/var(data)) # set initial guess for probability for neg-binomfit#
nbsizeguess = mean(data)*(1-nbprobguess)/nbprobguess #set initial guess for size for neg-binomfit#
nbiguess = c(prob=nbprobguess, size=nbsizeguess) #list of initial guesses for fit of neg-binomial distribution.  These are calulated #
#
nbinomrun = fitdiscdist(data,dnbinom,nbiguess) #fit the data to a negative binomial distribution#
poisrun = fitdiscdist(data,dpois,mean(data)) #fit the data to a poisson distribution#
#
hist(data,n=24,col="red",freq=FALSE, main="Poisson and Negative Binomial Fits to SARS Data",#
     xlab="Number of Infections",ylab="Proportion of Cases")#
pys = dpois(0:33,lambda=poisrun$par)#
dnys = dnbinom(0:33,size=nbinomrun$par['size'],prob=nbinomrun$par['prob'])#
xs = 0:33#
lines(xs,pys,col="green",lwd=2)#
lines(xs,dnys,col="blue",lwd=2)#
legend(15,0.6,c(paste("Poisson (AIC = ",round(poisrun$AIC,2),")"),#
       paste("Neg-Binom (AIC = ",round(nbinomrun$AIC,2),")")), col=c("green","blue"), #
       lty=c(1,1))#
       #
       dnbinom
#ECL 298 HW Week 6: Fitting Negative Binomial#
#Noam Ross, February 11, 2011#
#
fitdiscdist <- function(data, distpick, guesspars) {#
# This function fits a discrete probability distribution to a distribution of #
# data, using a maximum-likelihood method.#
# Arguments:#
#   data: a vector of integers representing the data to be fit#
#   distpick: the distribution to use to fit, e.g. dpois, dnbinom#
#   guesspars: a set of initial guesses for the distribution parameters, in the form#
#     of a vector with names#
  optim.out = optim(guesspars, negloglike, method="BFGS",data=data, distpick=distpick) #run optimize function on negloglike function,#
  AIC = 2*length(guesspars) + 2*optim.out$value #calculate information criterion#
  out = list(pars=optim.out$par, likelihood=(-optim.out$value), AIC=AIC) #package outputs as list#
  return(out) #output the list#
}#
#
negloglike <- function(pars, data, distpick) {#
# This function calculates the negative log likelihood of data under a given function and parameters#
# Arguments:#
#   data: a vector of integers representing the data to be fit#
#   distpick: the distribution to use to fit, e.g. dpois, dnbinom#
#   pars: a set of initial guesses for the distribution parameters, in the form#
#     of a list with names#
  callparms = c(list(x=data,log=TRUE), as.list(pars))  #create a unified list of arguments#
  loglikelihoods = do.call(distpick, callparms) #call the distribution function with those arguments#
  out = -sum(loglikelihoods)   #sum the loglikelihoods#
  return(out) #output the optimizing value#
#
}#
#
#Work session to fit data#
data=c(33,rep(0,25),rep(1,3),rep(2,2),rep(2,3),8,10,rep(0,19),12) #create the data to fit#
nbprobguess = 1-(mean(data)/var(data)) # set initial guess for probability for neg-binomfit#
nbsizeguess = mean(data)*(1-nbprobguess)/nbprobguess #set initial guess for size for neg-binomfit#
nbiguess = c(prob=nbprobguess, size=nbsizeguess) #list of initial guesses for fit of neg-binomial distribution.  These are calulated #
#
nbinomrun = fitdiscdist(data,dnbinom,nbiguess) #fit the data to a negative binomial distribution#
poisrun = fitdiscdist(data,dpois,mean(data)) #fit the data to a poisson distribution#
#
#Plot data#
hist(data,n=24,col="red",freq=FALSE, main="Poisson and Negative Binomial Fits to SARS Data",#
     xlab="Number of Infections",ylab="Proportion of Cases")#
pys = dpois(0:33,lambda=poisrun$par)#
dnys = dnbinom(0:33,size=nbinomrun$par['size'],prob=nbinomrun$par['prob'])#
xs = 0:33#
lines(xs,pys,col="green",lwd=2)#
lines(xs,dnys,col="blue",lwd=2)#
legend(15,0.6,c(paste("Poisson (AIC = ",round(poisrun$AIC,2),")"),#
       paste("Neg-Binom (AIC = ",round(nbinomrun$AIC,2),")")), col=c("green","blue"), #
       lty=c(1,1))
