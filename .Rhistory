setwd('/Users/noamross/Dropbox/Workspace/_WorkingCode/OldStuff')
rm(list=ls()) #clear workspace
setwd('/Users/noamross/Dropbox/Workspace/_WorkingCode/OldStuff')
source("fit_ode.R") #load functions
setwd('/Users/noamross/Dropbox/Workspace/_WorkingCode/OldStuff')
#set parameters#
r = c(0.7816, 0.6283)  #r and K are given#
K = c(559.686, 202.4931)#
alphas = rbind(c(1,"a21"),c("a12",1)) #create alpha matrix with unknowns#
parms = list(r=r,K=K,alphas=alphas)  #bind into named list#
guesses = c(a21=0.5, a12=0.5)	#create named vector of guesses#
nTrue = as.matrix(read.table("paramecium2.txt")) #load data
setwd('/Users/noamross/Dropbox/Workspace/_WorkingCode/OldStuff')
nTrue = as.matrix(read.table("./data/paramecium2.txt")) #load data
setwd('/Users/noamross/Dropbox/Workspace/_WorkingCode/OldStuff')
nTrue = as.matrix(read.table("../data/paramecium2.txt")) #load data
setwd('/Users/noamross/Dropbox/Workspace/_WorkingCode/OldStuff')
#run fitting function#
fit = fit_ode(LotVolt,parms,guesses,nTrue) #
#
#calculate some values for plotting#
times = 1:dim(nTrue)[1]   #times vector#
parms2 = numeric.list(replace.variables(fit$par, parms)) #create parameter list with fitted outputs#
nSim = lsoda(nTrue[1,],times,LotVolt,parms2) #solve the ODEs with fitted values#
#
#plots#
plot(times,nTrue[,1], main="Lotka-Volterra ODE Model fit to Data",xlab="time",ylab="Population")  #plot the real data#
points(times,nTrue[,2])#
lines(times,nSim[,2])	#add the model fit lines#
lines(times,nSim[,3])#
legend("topleft",c("Data","Model Fit"),lty=c("blank","solid"),pch=c(1,NA_integer_)) #create a legend#
text(3.3,300,bquote(alpha[21] == .(fit$par[1])))  #annotate with alpha values#
text(3.3,280,bquote(alpha[12] == .(fit$par[2])))
d :s df :s :d df _df Noam Ross#
Graduate Group in Ecology#
Department of Environmental Science and Policy#
University of California at Davis#
+1.646.244.0484#
http://www.noamross.net/#
twitter: @noamross
setwd('/Users/noamross/.Trash/Workdir')
r = c(0.7816, 0.6283)  #r and K are given
setwd('/Users/noamross/.Trash/Workdir')
r = c(0.7816, 0.6283)  #r and K are given
parms = list(r=r,K=K,alphas=alphas)  #bind into named list
nTrue = as.matrix(read.table("paramecium2.txt")) #load data
guesses = c(a21=0.5, a12=0.5)	#create named vector of guesses
nTrue = as.matrix(read.table("paramecium2.txt")) #load data
nTrue = as.matrix(read.table("../data/paramecium2.txt")) #load data
nTrue = as.matrix(read.table(data/paramecium2.txt")) #load data
nTure
nTrue
rm(list=ls()) #clear workspace#
#
source("fit_ode.R") #load functions#
#
#
#set parameters#
r = c(0.7816, 0.6283)  #r and K are given#
K = c(559.686, 202.4931)#
alphas = rbind(c(1,"a21"),c("a12",1)) #create alpha matrix with unknowns#
parms = list(r=r,K=K,alphas=alphas)  #bind into named list#
guesses = c(a21=0.5, a12=0.5)	#create named vector of guesses#
nTrue = as.matrix(read.table("paramecium2.txt")) #load data#
#
#run fitting function#
fit = fit_ode(LotVolt,parms,guesses,nTrue) #
#
#calculate some values for plotting#
times = 1:dim(nTrue)[1]   #times vector#
parms2 = numeric.list(replace.variables(fit$par, parms)) #create parameter list with fitted outputs#
nSim = lsoda(nTrue[1,],times,LotVolt,parms2) #solve the ODEs with fitted values#
#
#plots#
plot(times,nTrue[,1], main="Lotka-Volterra ODE Model fit to Data",xlab="time",ylab="Population")  #plot the real data#
points(times,nTrue[,2])#
lines(times,nSim[,2])	#add the model fit lines#
lines(times,nSim[,3])#
legend("topleft",c("Data","Model Fit"),lty=c("blank","solid"),pch=c(1,NA_integer_)) #create a legend#
text(3.3,300,bquote(alpha[21] == .(fit$par[1])))  #annotate with alpha values#
text(3.3,280,bquote(alpha[12] == .(fit$par[2])))
rm(list=ls()) #clear workspace#
#
source("fit_ode.R") #load functions#
#
#
#set parameters#
r = c(0.7816, 0.6283)  #r and K are given#
K = c(559.686, 202.4931)#
alphas = rbind(c(1,"a21"),c("a12",1)) #create alpha matrix with unknowns#
parms = list(r=r,K=K,alphas=alphas)  #bind into named list#
guesses = c(a21=0.5, a12=0.5)	#create named vector of guesses#
nTrue = as.matrix(read.table("data/paramecium2.txt")) #load data#
#
#run fitting function#
fit = fit_ode(LotVolt,parms,guesses,nTrue) #
#
#calculate some values for plotting#
times = 1:dim(nTrue)[1]   #times vector#
parms2 = numeric.list(replace.variables(fit$par, parms)) #create parameter list with fitted outputs#
nSim = lsoda(nTrue[1,],times,LotVolt,parms2) #solve the ODEs with fitted values#
#
#plots#
plot(times,nTrue[,1], main="Lotka-Volterra ODE Model fit to Data",xlab="time",ylab="Population")  #plot the real data#
points(times,nTrue[,2])#
lines(times,nSim[,2])	#add the model fit lines#
lines(times,nSim[,3])#
legend("topleft",c("Data","Model Fit"),lty=c("blank","solid"),pch=c(1,NA_integer_)) #create a legend#
text(3.3,300,bquote(alpha[21] == .(fit$par[1])))  #annotate with alpha values#
text(3.3,280,bquote(alpha[12] == .(fit$par[2])))
rm(list=ls()) #clear workspace#
#
source("OldStuff/fit_ode.R") #load functions#
#
#
#set parameters#
r = c(0.7816, 0.6283)  #r and K are given#
K = c(559.686, 202.4931)#
alphas = rbind(c(1,"a21"),c("a12",1)) #create alpha matrix with unknowns#
parms = list(r=r,K=K,alphas=alphas)  #bind into named list#
guesses = c(a21=0.5, a12=0.5)	#create named vector of guesses#
nTrue = as.matrix(read.table("data/paramecium2.txt")) #load data#
#
#run fitting function#
fit = fit_ode(LotVolt,parms,guesses,nTrue) #
#
#calculate some values for plotting#
times = 1:dim(nTrue)[1]   #times vector#
parms2 = numeric.list(replace.variables(fit$par, parms)) #create parameter list with fitted outputs#
nSim = lsoda(nTrue[1,],times,LotVolt,parms2) #solve the ODEs with fitted values#
#
#plots#
plot(times,nTrue[,1], main="Lotka-Volterra ODE Model fit to Data",xlab="time",ylab="Population")  #plot the real data#
points(times,nTrue[,2])#
lines(times,nSim[,2])	#add the model fit lines#
lines(times,nSim[,3])#
legend("topleft",c("Data","Model Fit"),lty=c("blank","solid"),pch=c(1,NA_integer_)) #create a legend#
text(3.3,300,bquote(alpha[21] == .(fit$par[1])))  #annotate with alpha values#
text(3.3,280,bquote(alpha[12] == .(fit$par[2])))
[1] 559.6860 202.4931
setwd('/Users/noamross/.Trash/Workdir')
r = c(0.7816, 0.6283)  #r and K are given#
K = c(559.686, 202.4931)#
alphas = rbind(c(1,"a21"),c("a12",1)) #create alpha matrix with unknowns#
parms = list(r=r,K=K,alphas=alphas)  #bind into named list#
guesses = c(a21=0.5, a12=0.5)	#create named vector of guesses
setwd('/Users/noamross/.Trash/Workdir')
r = c(0.7816, 0.6283)  #r and K are given#
K = c(559.686, 202.4931)#
alphas = rbind(c(1,"a21"),c("a12",1)) #create alpha matrix with unknowns#
parms = list(r=r,K=K,alphas=alphas)  #bind into named list#
guesses = c(a21=0.5, a12=0.5)	#create named vector of guesses
parms = list(r=r,K=K,alphas=alphas)  #bind into named list
r = c(0.7816, 0.6283)  #r and K are given#
K = c(559.686, 202.4931)#
alphas = rbind(c(1,"a21"),c("a12",1)) #create alpha matrix with unknowns#
parms = list(r=r,K=K,alphas=alphas)  #bind into named list#
guesses = c(a21=0.5, a12=0.5)	#create named vector of guesses#
nTrue = as.matrix(read.table("data/paramecium2.txt")) #load data
source("OldStuff/fit_ode.R") #load functions
#set parameters
r = c(0.7816, 0.6283)  #r and K are given
K = c(559.686, 202.4931)
alphas = rbind(c(1,"a21"),c("a12",1)) #create alpha matrix with unknowns
rm(list=ls()) #clear workspace#
#
source("OldStuff/fit_ode.R") #load functions#
#
#
#set parameters#
r = c(0.7816, 0.6283)  #r and K are given#
K = c(559.686, 202.4931)#
alphas = rbind(c(1,"a21"),c("a12",1)) #create alpha matrix with unknowns#
parms = list(r=r,K=K,alphas=alphas)  #bind into named list#
guesses = c(a21=0.5, a12=0.5)	#create named vector of guesses#
nTrue = as.matrix(read.table("data/paramecium2.txt")) #load data#
#
#run fitting function#
fit = fit_ode(LotVolt,parms,guesses,nTrue) #
#
#calculate some values for plotting#
times = 1:dim(nTrue)[1]   #times vector#
parms2 = numeric.list(replace.variables(fit$par, parms)) #create parameter list with fitted outputs#
nSim = lsoda(nTrue[1,],times,LotVolt,parms2) #solve the ODEs with fitted values#
#
#plots#
plot(times,nTrue[,1], main="Lotka-Volterra ODE Model fit to Data",xlab="time",ylab="Population")  #plot the real data#
points(times,nTrue[,2])#
lines(times,nSim[,2])	#add the model fit lines#
lines(times,nSim[,3])#
legend("topleft",c("Data","Model Fit"),lty=c("blank","solid"),pch=c(1,NA_integer_)) #create a legend#
text(3.3,300,bquote(alpha[21] == .(fit$par[1])))  #annotate with alpha values#
text(3.3,280,bquote(alpha[12] == .(fit$par[2])))
alphas = rbind(c(1,"a21"),c("a12",1)) #create alpha matrix with unknowns
parms = list(r=r,K=K,alphas=alphas)  #bind into named list
guesses = c(a21=0.5, a12=0.5)	#create named vector of guesses
nTrue = as.matrix(read.table("data/paramecium2.txt")) #load data
#run fitting function
fit = fit_ode(LotVolt,parms,guesses,nTrue)
#calculate some values for plotting
times = 1:dim(nTrue)[1]   #times vector
parms2 = numeric.list(replace.variables(fit$par, parms)) #create parameter list with fitted outputs
nSim = lsoda(nTrue[1,],times,LotVolt,parms2) #solve the ODEs with fitted values
p = 2 #number of patches
lambda = 20 #population growth coefficient#
a = 1 #intraspecific competition term#
d = 0.04 #dispersal coefficient#
p = 2 #number of patches#
#N0 = runif(p)*10 #initial conditions#
tf = 500 #number of time steps#
N0s = seq(0,lambda/exp(1),length.out=100)
D = matrix(d/(p-1),p,p) #create disperal matrix with uniform dispersal#
diag(D) = 1-d#
#
N = matrix(0,tf,p) #create variable space for individual run outputs#
final.Ns = array(0, dim = c(rep(length(N0s), p), p))
dim(final.Ns)
#set parameters#
lambda = 20 #population growth coefficient#
a = 1 #intraspecific competition term#
d = 0.04 #dispersal coefficient#
p = 2 #number of patches#
#N0 = runif(p)*10 #initial conditions#
tf = 500 #number of time steps#
N0s = seq(0,lambda/exp(1),length.out=100) #vector of initial conditions to test#
#
#
#create dispersal matrix#
D = matrix(d/(p-1),p,p) #create disperal matrix with uniform dispersal#
diag(D) = 1-d#
#
N = matrix(0,tf,p) #create variable space for individual run outputs#
final.Ns = array(0, dim = c(rep(length(N0s), p), p))#
#
ricker.growth = function(N, lambda, a) { #density dependent growth function#
	N2 = lambda*N*exp(-a*N)#
	return(N2)#
	}
#set parameters#
lambda = 20 #population growth coefficient#
a = 1 #intraspecific competition term#
d = 0.04 #dispersal coefficient#
p = 2 #number of patches#
#N0 = runif(p)*10 #initial conditions#
tf = 500 #number of time steps#
N0s = seq(0,lambda/exp(1),length.out=10) #vector of initial conditions to test#
#
#
#create dispersal matrix#
D = matrix(d/(p-1),p,p) #create disperal matrix with uniform dispersal#
diag(D) = 1-d#
#
N = matrix(0,tf,p) #create variable space for individual run outputs#
final.Ns = array(0, dim = c(rep(length(N0s), p), p))#
#
ricker.growth = function(N, lambda, a) { #density dependent growth function#
	N2 = lambda*N*exp(-a*N)#
	return(N2)#
	}
dim(final.Ns)
for(k in 1:length(N0s)) {#
  for(j in 1:length(N0s)) {#
    N[1,] = N0s[] #set initial conditions from N0s#
#
    for(i in 1:(tf-1)) { #for each time i...#
    	N[i+1,] = D%*%ricker.growth(N[i,], lambda, a) #calculate next values of N#
    	}#
    	#
    final.Ns[k,j,] = N[length(N),]#
    }#
  }
for(k in 1:length(N0s)) {#
  for(j in 1:length(N0s)) {#
    N[1,] = c(N0s[j], N0s[k]) #set initial conditions from N0s#
#
    for(i in 1:(tf-1)) { #for each time i...#
    	N[i+1,] = D%*%ricker.growth(N[i,], lambda, a) #calculate next values of N#
    	}#
    	#
    final.Ns[k,j,] = N[length(N),]#
    }#
  }
N0s
final.Ns
N
k =1
j=1
N[1,] = c(N0s[j], N0s[k])
c(N0s[j], N0s[k])
k = 3
j = 2
c(N0s[j], N0s[k])
rm(list=ls()) #clear workspace#
#
#set parameters#
lambda = 20 #population growth coefficient#
a = 1 #intraspecific competition term#
d = 0.04 #dispersal coefficient#
p = 2 #number of patches#
#N0 = runif(p)*10 #initial conditions#
tf = 500 #number of time steps#
N0s = seq(0,lambda/exp(1),length.out=10) #vector of initial conditions to test#
#
#
#create dispersal matrix#
D = matrix(d/(p-1),p,p) #create disperal matrix with uniform dispersal#
diag(D) = 1-d#
#
N = matrix(0,tf,p) #create variable space for individual run outputs#
final.Ns = array(0, dim = c(rep(length(N0s), p), p))#
#
ricker.growth = function(N, lambda, a) { #density dependent growth function#
	N2 = lambda*N*exp(-a*N)#
	return(N2)#
	}#
#
#
for(k in 1:length(N0s)) {#
  for(j in 1:length(N0s)) {#
    N[1,] = c(N0s[j], N0s[k]) #set initial conditions from N0s#
#
    for(i in 1:(tf-1)) { #for each time i...#
    	N[i+1,] = D%*%ricker.growth(N[i,], lambda, a) #calculate next values of N#
    	}#
    	#
    final.Ns[k,j,] = N[length(N),]#
    }#
  }
N
    final.Ns[k,j,] = N[tf,]
rm(list=ls()) #clear workspace#
#
#set parameters#
lambda = 20 #population growth coefficient#
a = 1 #intraspecific competition term#
d = 0.04 #dispersal coefficient#
p = 2 #number of patches#
#N0 = runif(p)*10 #initial conditions#
tf = 500 #number of time steps#
N0s = seq(0,lambda/exp(1),length.out=10) #vector of initial conditions to test#
#
#
#create dispersal matrix#
D = matrix(d/(p-1),p,p) #create disperal matrix with uniform dispersal#
diag(D) = 1-d#
#
N = matrix(0,tf,p) #create variable space for individual run outputs#
final.Ns = array(0, dim = c(rep(length(N0s), p), p))#
#
ricker.growth = function(N, lambda, a) { #density dependent growth function#
	N2 = lambda*N*exp(-a*N)#
	return(N2)#
	}#
#
#
for(k in 1:length(N0s)) {#
  for(j in 1:length(N0s)) {#
    N[1,] = c(N0s[j], N0s[k]) #set initial conditions from N0s#
#
    for(i in 1:(tf-1)) { #for each time i...#
    	N[i+1,] = D%*%ricker.growth(N[i,], lambda, a) #calculate next values of N#
    	}#
    	#
    final.Ns[k,j,] = N[tf,]#
    }#
  }
final.Ns
image(N0s,N0s,log(abs(final.Ns[,,1] - final.Ns[,,2])))
rm(list=ls()) #clear workspace#
#
#set parameters#
lambda = 20 #population growth coefficient#
a = 1 #intraspecific competition term#
d = 0.04 #dispersal coefficient#
p = 2 #number of patches#
#N0 = runif(p)*10 #initial conditions#
tf = 500 #number of time steps#
N0s = seq(0,lambda/exp(1),length.out=100) #vector of initial conditions to test#
#
#
#create dispersal matrix#
D = matrix(d/(p-1),p,p) #create disperal matrix with uniform dispersal#
diag(D) = 1-d#
#
N = matrix(0,tf,p) #create variable space for individual run outputs#
final.Ns = array(0, dim = c(rep(length(N0s), p), p))#
#
ricker.growth = function(N, lambda, a) { #density dependent growth function#
	N2 = lambda*N*exp(-a*N)#
	return(N2)#
	}#
#
#
for(k in 1:length(N0s)) {#
  for(j in 1:length(N0s)) {#
    N[1,] = c(N0s[j], N0s[k]) #set initial conditions from N0s#
#
    for(i in 1:(tf-1)) { #for each time i...#
    	N[i+1,] = D%*%ricker.growth(N[i,], lambda, a) #calculate next values of N#
    	}#
    	#
    final.Ns[k,j,] = N[tf,]#
    }#
  }#
#
image(N0s,N0s,log(abs(final.Ns[,,1] - final.Ns[,,2])))
stop
stop#
stop()
rm(list=ls()) #clear workspace#
#
#set parameters#
lambda = 20 #population growth coefficient#
a = 1 #intraspecific competition term#
d = 0.04 #dispersal coefficient#
p = 2 #number of patches#
#N0 = runif(p)*10 #initial conditions#
tf = 500 #number of time steps#
N0s = seq(0,lambda/exp(1),length.out=100) #vector of initial conditions to test#
#
#
#create dispersal matrix#
D = matrix(d/(p-1),p,p) #create disperal matrix with uniform dispersal#
diag(D) = 1-d#
#
N = matrix(0,tf,p) #create variable space for individual run outputs#
final.Ns = array(0, dim = c(rep(length(N0s), p), p))#
#
ricker.growth = function(N, lambda, a) { #density dependent growth function#
	N2 = lambda*N*exp(-a*N)#
	return(N2)#
	}#
#
#
for(k in 1:length(N0s)) {#
  for(j in 1:length(N0s)) {#
    N[1,] = c(N0s[j], N0s[k]) #set initial conditions from N0s#
#
    for(i in 1:(tf-1)) { #for each time i...#
    	N[i+1,] = D%*%ricker.growth(N[i,], lambda, a) #calculate next values of N#
    	}#
    	#
    final.Ns[k,j,] = N[tf,]#
    }#
  }#
#
image(N0s,N0s,log(abs(final.Ns[,,1] - final.Ns[,,2])))
help(system)
system("git add .")
system("git add .", intern=TRUE)
system(git add ., intern=TRUE)
system("git add .", intern=TRUE)
image(N0s,N0s,log(abs(final.Ns[,,1] - final.Ns[,,2])), col=rainbow(128),#
      xlab="Initial Population at Patch 1",#
      ylab="Inital Population at Patch 2",#
      main="Log Population Differences of Two Patches following Hastings 1990")
##
#
rm(list=ls()) #clear workspace#
#
#set parameters#
lambda = 20 #population growth coefficient#
a = 1 #intraspecific competition term#
d = 0.04 #dispersal coefficient#
p = 2 #number of patches#
#N0 = runif(p)*10 #initial conditions#
tf = 500 #number of time steps#
N0s = seq(0,lambda/exp(1),length.out=20) #vector of initial conditions to test#
#
#
#create dispersal matrix#
D = matrix(d/(p-1),p,p) #create disperal matrix with uniform dispersal#
diag(D) = 1-d#
#
N = matrix(0,tf,p) #create variable space for individual run outputs#
final.Ns = array(0, dim = c(rep(length(N0s), p), p))#
#
ricker.growth = function(N, lambda, a) { #density dependent growth function#
	N2 = lambda*N*exp(-a*N)#
	return(N2)#
	}#
#
#
for(k in 1:length(N0s)) {#
  for(j in 1:length(N0s)) {#
    N[1,] = c(N0s[j], N0s[k]) #set initial conditions from N0s#
#
    for(i in 1:(tf-1)) { #for each time i...#
    	N[i+1,] = D%*%ricker.growth(N[i,], lambda, a) #calculate next values of N#
    	}#
    	#
    final.Ns[k,j,] = N[tf,]#
    }#
  }#
#
image(N0s,N0s,log(abs(final.Ns[,,1] - final.Ns[,,2])), col=rainbow(128),#
      xlab="Initial Population at Patch 1",#
      ylab="Inital Population at Patch 2",#
      main="Log Population Differences of Two Patches following Hastings 1990")
save(final.Ns, file="Data/HastingsModelOut")
save(final.Ns, file="Data/HastingsModelOut")
image(N0s,N0s,log(abs(final.Ns[,,1] - final.Ns[,,2])), col=rainbow(256),#
      xlab="Initial Population at Patch 1",#
      ylab="Inital Population at Patch 2",#
      main="Log Population Differences of Two Patches following Hastings 1990")
rm(list=ls()) #clear workspace
help(save)
save("Data/HastingsModelOut")
help(save)
load("Data/HastingsModelOut")
rm(list=ls()) #clear workspace
image(N0s,N0s,log(abs(final.Ns[,,1] - final.Ns[,,2])), col=rainbow(256),#
      xlab="Initial Population at Patch 1",#
      ylab="Inital Population at Patch 2",#
      main="Log Population Differences of Two Patches following Hastings 1990")
N0s = seq(0,lambda/exp(1),length.out=20) #vector of initial conditions to test
lambda = 20 #population growth coefficient#
a = 1 #intraspecific competition term#
d = 0.04 #dispersal coefficient#
p = 2 #number of patches#
#N0 = runif(p)*10 #initial conditions#
tf = 500 #number of time steps#
N0s = seq(0,lambda/exp(1),length.out=20) #vector of initial conditions to test
image(N0s,N0s,log(abs(final.Ns[,,1] - final.Ns[,,2])), col=rainbow(256),#
      xlab="Initial Population at Patch 1",#
      ylab="Inital Population at Patch 2",#
      main="Log Population Differences of Two Patches following Hastings 1990")
load("Data/HastingsModelOut.rdata")
load("Data/HastingsModelOut")
image(N0s,N0s,log(abs(final.Ns[,,1] - final.Ns[,,2])), col=rainbow(256),#
      xlab="Initial Population at Patch 1",#
      ylab="Inital Population at Patch 2",#
      main="Log Population Differences of Two Patches following Hastings 1990")
##
#
rm(list=ls()) #clear workspace#
#
#set parameters#
lambda = 20 #population growth coefficient#
a = 1 #intraspecific competition term#
d = 0.04 #dispersal coefficient#
p = 2 #number of patches#
#N0 = runif(p)*10 #initial conditions#
tf = 500 #number of time steps#
N0s = seq(0,lambda/exp(1),length.out=400) #vector of initial conditions to test#
#
#
#create dispersal matrix#
D = matrix(d/(p-1),p,p) #create disperal matrix with uniform dispersal#
diag(D) = 1-d#
#
N = matrix(0,tf,p) #create variable space for individual run outputs#
final.Ns = array(0, dim = c(rep(length(N0s), p), p))#
#
ricker.growth = function(N, lambda, a) { #density dependent growth function#
	N2 = lambda*N*exp(-a*N)#
	return(N2)#
	}#
#
#
for(k in 1:length(N0s)) {#
  for(j in 1:length(N0s)) {#
    N[1,] = c(N0s[j], N0s[k]) #set initial conditions from N0s#
#
    for(i in 1:(tf-1)) { #for each time i...#
    	N[i+1,] = D%*%ricker.growth(N[i,], lambda, a) #calculate next values of N#
    	}#
    	#
    final.Ns[k,j,] = N[tf,]#
    }#
  }#
#
save(final.Ns, file="Data/HastingsModelOut.rdata")#
image(N0s,N0s,log(abs(final.Ns[,,1] - final.Ns[,,2])), col=rainbow(256),#
      xlab="Initial Population at Patch 1",#
      ylab="Inital Population at Patch 2",#
      main="Log Population Differences of Two Patches following Hastings 1990")
